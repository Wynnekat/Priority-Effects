---
title: "Priority Effects"
author: K. Carter Wynne
output: 
  html_document:
    smart: no
    theme: flatly
    float: yes
    css: "style.css"    
editor_options: 
  chunk_output_type: console
mainfont: Arial
mathfont: Arial
fontsize: 12pt
---

#  {.tabset .tabset-pills .tabset-fade}

## Overview

### **The role of temporal dispersal patterns in building diverse tallgrass prairie plant communities**

**Background**: 

Establishing diverse plant communities is critical since diversity is linked to ecosystem health. However, recreating tallgrass prairies with high plant diversity has been challenging, especially for early-season species. Variation in species arrival may influence plant community composition and diversity. Since prairies exhibit temporal patterns of seed dispersal, planting all species simultaneously could forgo phenological differences that promote species coexistence. Therefore, we investigated whether manipulating plant species' arrival according to natural dispersal phenology influences reconstruction outcomes.  

In 2021, we manipulated the arrival of 36 species via seed additions of (i) species in the order of peak dispersal timing, (ii) summer dispersing species (first peak in dispersal activity before September 1st) followed by 18 fall dispersing species, (iii) 18 fall dispersing species followed by 18 summer dispersing species, (iv) all species simultaneously. Additionally, we had a negative control that had no seed additions. One year later, we found that differences in seeding treatment influenced the diversity and composition of reconstructed communities. Species arriving later had less cover than when seeded with priority, particularly for summer dispersing species. Overall, our study provides evidence of priority effects in reconstructed grasslands and suggests that the timing of seed additions post-disturbance influences restoration outcomes.


**Author:** Katherine Carter Wynne ([Wynnekat\@msu.edu](mailto:Wynnekat@msu.edu){.email})

**Co-authors:** Lauren L. Sullivan

**Created:** 06 December 2022

------------------------------------------------------------------------

**Files:**

1) *PE_Cover_Inner_Fall_2021_Cleaned.xlsx*  - vegetative cover taken at peak biomass in 2021 (August 27th - August 30th); only half of the lumped seedings occured.

2) *PE_Cover_Inner_Summer_2022_Cleaned.xlsx* - vegetative cover measured in Summer 2022 (June 27th - June 28th)

3) *PE_Cover_Inner_Fall_2022_Cleaned.xlsx* - vegetative cover taken at peak biomass in 2022 (August 25th - August 26th)

4) *PE_Cover_Inner_Summer_2023_Cleaned.xlsx* - vegetative cover measured in Summer 2023 (June 21st - June 23rd)

5) *PE_Cover_Inner_Fall_2023_Cleaned.xlsx* - vegetative cover taken at peak biomass in 2023 (August 10th - August 11th) 

6) *Bradford_10_Year_Weather.xlsx* - weather (temperature and precipitation) data from the last 10 years at Bradford Research Farm

7) *Priority_Effects_Fall_2022_Light.xlsx* - light data from August 2022; measured at the same time as peak biomass cover

8) *Priority_Effects_Fall_2023_Light.xlsx* - light data from August 2023; measured at the same time as peak biomass cover

9) *PE_Bare_Ground_Cleaned_2021.xlsx* - Litter and bare ground cover from August 2021

10) *Species_List.xlsx* - Species list


------------------------------------------------------------------------

**R Version:** R 4.2.2

**RStudio Version:** 2023.06.1+524

**Package Version:** Found in the .readme document in GitHub Repository

**Last updated: 29 September 2023**

------------------------------------------------------------------------


## Overall Setup {.tabset}

**Materials and Methods**

*Study Site*

Our experiment utilized a former agricultural field (~1 acre) at the University of Missouri’s Bradford Research Center in Columbia, MO (38.893604, -92.201154, Boone County, MO). Typical for the central U.S., the 10-year (2011 – 2021) mean annual precipitation and average air temperature at Bradford Research Center were 927.74 $\pm$ 143.01 mm and 12.40 $\pm$ 10.45 $\circ$C, respectively (Commercial Agriculture Automated Weather Station Network, d.n.). Prior to our experiment, the field we grew herbicide-resistant soybeans for at least three years, reflecting conditions similar to most prairie reconstructions before seeding (Rowe, 2010; Newbold et al., 2019). In March 2021, we tilled our study site and hand-removed rhizome clumps to create a smooth surface before our first seeding. 


*Experimental Design*

We used seed additions to manipulate the arrival of 36 native tallgrass prairie plant species. Since prairies experience two peaks in dispersal activity (Rabinowitz & Rapp 1980), we classified species into two dispersal guilds, summer-dispersing species (first peak in dispersal activity before September 1st) and fall-dispersing species. Dispersal guild is more informative than flowering guild because dispersal does not always follow flowering (e.g., Penstemon digitalis). We based our classifications on expert opinion from the Missouri Department of Conservation, The Nature Conservancy, and our previous work on seed rain patterns in Missouri tallgrass prairies (Wynne et al. *in prep*). Species used in our study consisted of 29 native species captured in our previous study on seed rain and seven summer-dispersing species that restoration managers cited as having minimal success in prairie reconstructions (e.g., Viola pedatifida) (Table S1) (Barak et al., 2022). When possible, we obtained seeds from local ecotype commercial sellers. However, several summer-dispersing species were not grown commercially in Missouri and were sourced elsewhere. We stored the seeds in a refrigerator (2.78 $\circ$C) until seeding. 

We used a randomized factorial block design to test the effects of seeding timing and order (Fig. 1). Each block (n = 6) contained five plots (2 x 2 m) randomly assigned a seed addition treatment following one of the four arrival treatments:

1)	the addition of species in order of first peak in dispersal activity (NAT)

        - May 24th 2021 (VIOPED, PACPLA)
        - June 4th 2021 (SISCAM, SPHOBT, CORLAN)
        - June 22nd 2021 (LOBSPI, TRAOHI, CARBUS, HEURIC)
        - July 11th 2021 (CORPAL, DODMEA)
        - July 25th 2021 (KOEMAC, AMOCAN)
        - August 2nd 2021 (LINSUL, MELVIR)
        - August 21st 2021 (DALCAN, DALPUR, ACHMIL)
        - September 17th 2021 (CROSAG)
        - October 4th 2021 (CHAFAS, MONFIS, RATPIN, SPOHET, RUDHIR)
        - October 18th 2021 (BIDARI, HELMOL, LESCAP)
        - November 1st 2021 (PENDIG, ERYYUC, HYPPUN, SORNUT, SCHSCO, LIAPYC)
        - November 19th 2021 (CORTRI, PYCTEN, SOLRIG)
      

2)	the lumped addition of 18 summer-dispersing species on March 22nd, 2021 followed by a lumped addition of 18 fall-dispersing species approximately five months later on September 5th, 2021 (**LE**)


3) the lumped addition of 18 fall-dispersing species on March 22nd, 2021 followed by a lumped addition of 18 summer-dispersing species approximately five months later on September 5th, 2021 (**LL**)

4) the simultaneous addition of the entire species pool on March 22nd, 2021 typical of most prairie reconstructions (**SIM**).

Additionally, we had an unseeded negative control (NON) to determine whether active seeding treatments improved community diversity compared to passive regeneration from ambient seed sources (e.g., seed rain and soil seed bank). We also seeded white clover (*Trifolium repens*) between the experimental plots to prevent erosion. In fall 2022, we started annually removing invading white clover and woody species from plots. All other unseeded species were not weeded to better reflect realistic assembly and reconstruction processes.

We started seeding at the end of the dormant season (March 22nd, 2021) and continued until November 19th, 2021. We hand-seeded species into experimental plots at a density of 50 seeds $m^{-2}$  using sand as a broadcasting agent.  For treatments requiring multiple seedings, we incorporated M-Binder tackifier (Ecology Controls, Carpinteria, CA), a natural adhesive often used in hydroseeding, into the seeding mixes to increase soil-seed contact without disturbing the existing vegetation.  After seeding, we lightly watered plots to activate the tackifier. All plots received equal amounts of sand, tackifier, and water during every seeding.

*Data Collection*

Starting in 2022, we conducted floristic surveys to assess plant community diversity and composition in experimental plots for two years. To determine species abundance, we measured the percent aerial cover of all vascular plant species rooted within a 1 $m^{2}$ subplot in the center of the experimental plot. Because many seeded summer-dispersing species senesce before peak biomass (August – September), we measured vegetative cover twice yearly, once in the early summer (late June) and again at peak biomass (late August). We only used the highest percent cover value for species present in both surveys. We identified species according to Yatskievych (1999, 2006, 2013). Additionally, we measured environmental variables including percent bare ground cover and light levels in plots.  For each plot, we measured light levels using a (**insert name of light bar**) two times above the vegetation, in the midstory, and ground-level at solar noon $\pm$ 2 hours.


*Data Setup*

Each tab below contains the code used to import, clean, and manipulate data to later use for further analyses. 

      
### Load libraries {.tabset}

```{r, message = FALSE, warning = FALSE}

## Libraries


### ----- Data Cleaning and Management -----

# Import excel files

library(readxl)


# Export dataframes to excel files

library(writexl)


# Data cleaning and visualization

library(tidyverse)



### ----- Data Analysis -----

# Community ecology functions (NMDS, diversity indices, etc.)

library(vegan)
library(BiodiversityR)

# Mixed models

library(lme4)
library(lmerTest)
library(MuMIn)

# Checks model assumptions

library(rstatix)

### ----- Data visualization -----


#Functions that assist in making high quality figures

library(cowplot)
library(ggpubr)
library(ggrepel)
library(flextable)

```

### Import Datasets {.tabset}

```{r, message = FALSE, warning = FALSE}

## Import Datasets

## inner (1 m^2) cover for Summer
#### comprehensive vegetative cover (%) for all species in the inner (1 m^2) permanent sampling area. 

inner_cover_summer_2022 <- read_excel("~/Priority-Effects/Priority Effects - Github/Data/Cover/PE_Cover_Inner_Summer_2022_Cleaned.xlsx")

inner_cover_summer_2023 <- read_excel("~/Priority-Effects/Priority Effects - Github/Data/Cover/PE_Cover_Inner_Summer_2023_Cleaned.xlsx")

## inner (1 m^2) cover for Fall
#### comprehensive vegetative cover (%) for all species in the inner (1 m^2) permanent sampling area. 


inner_cover_fall_2021 <- read_excel("~/Priority-Effects/Priority Effects - Github/Data/Cover/PE_Cover_Inner_Fall_2021_Cleaned.xlsx")

inner_cover_fall_2022 <- read_excel("~/Priority-Effects/Priority Effects - Github/Data/Cover/PE_Cover_Inner_Fall_2022_Cleaned.xlsx")

inner_cover_fall_2023 <- read_excel("~/Priority-Effects/Priority Effects - Github/Data/Cover/PE_Cover_Inner_Fall_2023_Cleaned.xlsx")


## Bradford weather
weather <- read_excel("~/Priority-Effects/Priority Effects - Github/Data/Environment/Bradford_10_Year_Weather.xlsx")


## Light

light_fall_2022 <- read_excel("~/Priority-Effects/Priority Effects - Github/Data/Environment/Priority_Effects_Fall_2022_Light.xlsx")

light_fall_2023 <- read_excel("~/Priority-Effects/Priority Effects - Github/Data/Environment/Priority_Effects_Fall_2023_Light.xlsx")


## Bare and litter - 2021

bare_cover_2021 <- read_excel("~/Priority-Effects/Priority Effects - Github/Data/Cover/PE_Bare_Ground_Cleaned_2021.xlsx")


## Species list

species_list_PE <- read_excel("~/Priority-Effects/Priority Effects - Github/Data/Species_List.xlsx")
```


### Dataset cleaning {.tabset}


#### 2021 


```{r, message = FALSE, warning = FALSE}

## 2021 Inner Cover - Dataset cleaning


### Remove unnecessary columns

#### Get rid of the notes, unknown, and senensced columns

### Fall
inner_cover_fall_2021 <- inner_cover_fall_2021[,-c(6,7,8)]


#### change log
 # - senesced PLASPP changed to PLAVIR since PLALAN and PLAMAJ do not senesce until Oct.  (Sep 6, 2023)
 # - JUNSPP changed to JUNINT since JUNINT has been observed in 2022 and 2023 (Sep 6, 2023)


### Get rid of EMP

### Fall
inner_cover_fall_2021 <- subset(inner_cover_fall_2021, Treatment != "EMP")


```


#### 2022

```{r, message = FALSE, warning = FALSE}

## 2022 Inner Cover - Dataset cleaning

### Remove unnecessary columns

### Get rid of the notes, unknown, and sentenced columns

#### Summer
inner_cover_summer_2022 <- inner_cover_summer_2022[,-8]

#### change log
 # - Fixed IDs: most GALAPA -> GALPED and HEURIC -> GEUCAN (Sep 6, 2023)


#### Fall
inner_cover_fall_2022 <- inner_cover_fall_2022[,-c(8,9,10)]

#### change log
 # - Fixed IDs: VERSPP -> VERARV since this is the species observed in the summer (Sep 6, 2023)



### Get rid of EMP 

#### Summer
inner_cover_summer_2022 <- subset(inner_cover_summer_2022, Treatment != "EMP")

#### Fall
inner_cover_fall_2022 <- subset(inner_cover_fall_2022, Treatment != "EMP")
```



#### 2023

```{r, message = FALSE, warning = FALSE}

## 2023 Inner Cover - Dataset cleaning

### Remove unnecessary columns

### Get rid of the notes, unknown, and sentenced columns

#### Summer
inner_cover_summer_2023 <- inner_cover_summer_2023[,-c(6,7)]

#### change log
 # - Fixed IDs: was able to ID ALLSPP as ALLVIN (Sep 6, 2023)


#### Fall
inner_cover_fall_2023 <- inner_cover_fall_2023[,-c(6,7)]


### Get rid of EMP 

#### Summer
inner_cover_summer_2023 <- subset(inner_cover_summer_2023, Treatment != "EMP")

#### Fall
inner_cover_fall_2023 <- subset(inner_cover_fall_2023, Treatment != "EMP")
```

#### Joining Years 

```{r, message = FALSE, warning = FALSE}

#Checking to make sure all the SPP6 levels are correct (no misspellings or weirdness)

### Fall 2021
sort(unique(inner_cover_fall_2021$SPP6))

### Summer 2022
sort(unique(inner_cover_summer_2022$SPP6))

### Fall 2022
sort(unique(inner_cover_fall_2022$SPP6))

### Summer 2023
sort(unique(inner_cover_summer_2023$SPP6))

### Fall 2023
sort(unique(inner_cover_fall_2023$SPP6))

### ^ above looks good so far

```

```{r, message = FALSE, warning = FALSE}

# Make a unique identifier for year and season

### 2021

#### Season
inner_cover_fall_2021$Season <- rep("Fall", nrow=(inner_cover_fall_2021))
#### Year
inner_cover_fall_2021$Year <- rep("2021", nrow=(inner_cover_fall_2021))


### 2022

# Already has the identifiers
inner_cover_fall_2022$Year <- as.factor(inner_cover_fall_2022$Year)
inner_cover_summer_2022$Year <- as.factor(inner_cover_summer_2022$Year)

### 2023

#### Season
inner_cover_summer_2023$Season <- rep("Summer", nrow=(inner_cover_summer_2023))
inner_cover_fall_2023$Season <- rep("Fall", nrow=(inner_cover_fall_2023))

#### Year
inner_cover_fall_2023$Year <- rep("2023", nrow=(inner_cover_fall_2023))
inner_cover_fall_2023$Year <- as.factor(inner_cover_fall_2023$Year)

inner_cover_summer_2023$Year <- rep("2023", nrow=(inner_cover_summer_2023))
inner_cover_summer_2023$Year <- as.factor(inner_cover_summer_2023$Year)
```

```{r, message = FALSE, warning = FALSE}

# Join summer and fall cover for each year 

full_2021_data <- inner_cover_fall_2021

full_2022_data <- full_join(inner_cover_summer_2022,inner_cover_fall_2022)

full_2023_data <- full_join(inner_cover_summer_2023,inner_cover_fall_2023)


# Join all years together

### First 2021 and 2022
full_21_22_data <- full_join(full_2021_data, full_2022_data)

### Then 2021 and 2022 with 2023
full_year_data <- full_join(full_21_22_data, full_2023_data)

```

```{r, message = FALSE, warning = FALSE}

# lump certain taxa together 

### Lump the Carex for now (*****Ask Lauren about what to do about when the CARSPP > CARFRA or CARBRE?***)

## MELOFF + MELALB -> MELSPP
## LEPVIR -> LEPSPP
## CARFRA -> CARSPP
## CARBRE -> CARSPP

for(i in 1:nrow(full_year_data)) {
  if(full_year_data[i,3] == "CARFRA"){full_year_data [i,3] <- "CARSPP"}
  if(full_year_data[i,3] == "CARBRE"){full_year_data [i,3] <- "CARSPP"}
  if(full_year_data[i,3] == "MELOFF"){full_year_data [i,3] <- "MELSPP"}
  if(full_year_data[i,3] == "MELALB"){full_year_data [i,3] <- "MELSPP"}
  if(full_year_data[i,3] == "LEPSPP"){full_year_data [i,3] <- "LEPVIR"}
  if(full_year_data[i,3] == "ECHSPP"){full_year_data [i,3] <- "ECHCRU"}
  
  # Make all cover data that was less than 1 = to 1 (to make the data discrete)
  if(full_year_data[i,4] < 1) {full_year_data [i,4] <- 1}
  
}

```

```{r, message = FALSE, warning = FALSE}

# Function below takes that highest cover value for a species seen twice (e.g., once in the summer and again in fall)

inner_cover_max <- full_year_data  %>%
      group_by(Block, Treatment, Year, SPP6) %>%
      summarise(max_cover=max(Percent_Cover))

##### Note I manually checked species that were found in both the datasets (ACHMIL, TRIREP, CORLAN) and confirmed that the code above took the highest cover value for a species seen twice


### Remove Bare
inner_cover_max_only <- subset(inner_cover_max, SPP6 != "BARE")


### Remove Litter
inner_cover_max_only  <- subset(inner_cover_max_only, SPP6 != "LITTER")

```


```{r, message = FALSE, warning = FALSE}

#Checking again to make sure all the SPP6 levels are correct (no misspellings or weirdness)

sort(unique(inner_cover_max_only$SPP6))

SPP6_list <- sort(unique(inner_cover_max_only$SPP6))
SPP6_list <- as.data.frame(SPP6_list)

### Saw at least 94 different species across study
#### More since I had to lump MELOFF, MELALB, CARFRA, and CARBRE


### Function below makes the species list 

# write_xlsx(SPP6_list, "Species_List2.xlsx")
```


```{r, message = FALSE, warning = FALSE}

### Add species information to the dataset

#### N/A is N = native, A = non-native, G = Genus

inner_cover_max_only <- full_join(inner_cover_max_only, species_list_PE)

#Remove unnecessary columns

inner_cover_max_reduced <- inner_cover_max_only[, -c(6,7,10)]

```

#### Bare/Litter

```{r, message = FALSE, warning = FALSE}

### Bare dataset

inner_bare_cover <- subset(inner_cover_max, SPP6 == "BARE")

### Litter dataset

inner_litter_cover <- subset(inner_cover_max, SPP6 == "LITTER")


### Manipulate 2021 dataset to match 2022 and 2023

#### Bare Ground

bare_2021 <- subset(bare_cover_2021, Cover_Type != "Litter")
bare_2021 <- subset(bare_2021, Treatment != "EMP")
names(bare_2021) <- c("Block", "Treatment", "SPP6", "max_cover")
bare_2021$Year <- rep("2021", nrow(bare_2021))

for(i in 1:nrow(bare_2021)) {
  if(bare_2021[i,3] == "Bare"){bare_2021[i,3] <- "BARE"}
}

#### Litter 

litter_2021 <- subset(bare_cover_2021 , Cover_Type != "Bare")
litter_2021 <- subset(litter_2021, Treatment != "EMP")
names(litter_2021) <- c("Block", "Treatment", "SPP6", "max_cover")
litter_2021$Year <- rep("2021", nrow(litter_2021))


for(i in 1:nrow(litter_2021)) {
  if(bare_2021[i,3] == "Litter"){bare_2021[i,3] <- "LITTER"}
}


### Full_join datasets

inner_bare_cover <- full_join(inner_bare_cover, bare_2021)

inner_litter_cover <- full_join(inner_litter_cover, litter_2021)


```



## Question 1: Does timing of species arrival influence local diversity? {.tabset}


### Setup and Data Management

*Data Analysis*


We fit mixed-effects linear models with block as a random effect to determine whether year, timing of species arrival via seeding treatments, and the interaction between year and seeding treatments influenced local diversity (i.e., species richness, mean conservatism value, and Shannon diversity index) in reconstructed tallgrass prairie plant communities. In cases where random effect variance was estimated as near zero, we dropped the random effect and fit a simpler linear model instead. For each diversity model, we conducted a type III analysis of variance (ANOVA) followed by a posthoc Tukey test to determine significant pairwise differences. 

      
Below is the code used to calculate the species richness, mean conservatism value, and Shannon diversity index for each plot, treatment, and year combination. 

```{r, message = FALSE, warning = FALSE}

### Making a summary table of diversity indices between treatments

#Make a unique identifier for every block and treatment
inner_cover_max_reduced$UniqueBlock <- paste(inner_cover_max_reduced$Treatment, inner_cover_max_reduced$Block, sep="_")


### Making a community matrix

inner_cover_max_reduced_lumped <- inner_cover_max_reduced %>% 
  filter(Year != "2021") %>% 
  group_by(Block, Treatment, Year, SPP6) %>% 
  summarise(max_cover = sum(max_cover))


#Make a wide formatted dataset

inner_wide <- inner_cover_max_reduced_lumped  %>% 
  spread(key="SPP6", value="max_cover") 

#Replace NA values with 0

inner_wide[is.na(inner_wide)] <- 0 

#Make a separate dataframe for the labels
inner_wide.labs <- inner_wide[, c(1,2,3)]

#Turn our dataset into a matrix 
inner_wide_mat <- inner_wide[,-c(1,2,3)]


#Double check your work using the View() function. 

#View(inner_wide_mat)

```


```{r, message = FALSE, warning = FALSE}

## Calculate diversity metrics


# --- Species richness --- 

Species_richness <- specnumber(inner_wide_mat)


#  --- Shannon's Diversity --- 

#Calculate Shannon's Diversity
Shannon <- diversity(inner_wide_mat, index="shannon")


# --- Mean C --- 


# Make a dataset that has each treatment, the species found in that treatment, and their associated C values

inner_cover_max_reduced$C_Value <- as.numeric(inner_cover_max_reduced$C_Value)

C_hist <- inner_cover_max_reduced  %>% 
                  filter( C_Value >= 0) %>% 
                  group_by(Block, Treatment, SPP6, Year, C_Value) %>% 
            summarize(tot.cover = sum(max_cover)) %>% 
            select(-c(tot.cover))


# Calculate mean C for each Treatment in a Block
### Remember you have to filter out anything that isn't native!

Only_C <- inner_cover_max_reduced  %>% 
                  filter(Year != "2021") %>% 
                  filter( C_Value >= 0) %>% 
                  filter( C_Value != "NA") 

Only_C$C_Value <- as.numeric(Only_C$C_Value)

Mean_C <- Only_C %>% 
                  group_by(Block, Treatment, Year) %>% 
                  summarize(Mean_C = mean(C_Value))
```



### Diversity Indices - Summary Statistics


```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

# Make a new data frame to hold the diversity metrics
Summary_table <- data.frame(Mean_C$Treatment, Mean_C$Block, Mean_C$Year, Species_richness, Shannon, Mean_C$Mean_C)

# Summary table for the Mean C, Species Richness, and Shannon's diversity for each block, treatment, and year combination

Summary_table <- Summary_table %>% 
  rename(Treatment = Mean_C.Treatment, Block = Mean_C.Block, Year = Mean_C.Year, Mean_C = Mean_C.Mean_C)

```

Below is a summary table showing the mean and SD for mean C value (C), species richness (SR), and Shannon diversity index (SDI) for each seeding treatment.

```{r, echo = FALSE, message = FALSE}
# Summary table for the mean and standard deviation for C values, Species Richness, and Shannon's diversity for each treatment overall

Summary_table_mean <- Summary_table %>% 
  group_by(Treatment, Year) %>%   
  summarise(Mean_C_t = mean(Mean_C), SD_C = sd(Mean_C), mean_richness = mean(Species_richness), SD_richness = sd(Species_richness), mean_Shannon = mean(Shannon), SD_Shannon = sd(Shannon))
  
Summary_table_mean <- Summary_table_mean %>% 
rename(Treatment = Treatment, "C_Mean" = Mean_C_t, "C_SD" = SD_C, "SR_Mean" = mean_richness,"SR_SD" = SD_richness, "SDI_Mean" = mean_Shannon, "SDI_SD" = SD_Shannon )

```

```{r, echo = FALSE, message = FALSE}
flextable(Summary_table_mean) %>% 
  bold(part = "header") %>% 
  set_header_labels(values = list(
                      Treatment = "Treatment",
                      Year = "Year",
                    C_Mean = "C",
                   C_SD =  "\u00B1 SD",
                   SR_Mean = "Richness",
                   SR_SD = "\u00B1 SD",
                   SDI_Mean = "SDI",
                   SDI_SD = "\u00B1 SD")) %>% 
  colformat_double(
    big.mark = ",", digits = 2, na_str = "N/A"
  )
```


### Mean C {.tabset}

```{r}

BioR.theme <- theme(
panel.background = element_blank(),
panel.border = element_blank(),
panel.grid = element_blank(),
axis.line = element_line("gray25"),
text = element_text(size = 16, family="Arial"),
axis.text = element_text(size = 13, colour = "gray25"),
axis.title = element_text(size = 16, colour = "gray25"),
legend.title = element_text(size = 16),
legend.text = element_text(size = 16),
legend.key = element_blank())
```

#### Mean C - Model assumptions

Distribution of C values for all treatments were right skewed, indicating the majority of native plants in all treatments were of low conservatism value. Simultaneous seeding had the most "even" distribution of C values and almost every value was represented in this treatment. Across years, the largest changes in the distribution of C values were in the treatments that seeded the fall dispersing species in September. These changes were attributed to the replacement of species with low c values with more conservative species. Plots that were never seeded mainly consisted of species with low conservatism value. 

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

# Make a histogram showing the distribution of c values in each treatment

ggplot(data = C_hist, aes(x= C_Value, fill = Year)) +geom_density(bins =30, alpha =0.4) + facet_wrap(~Treatment) + scale_x_continuous(breaks = seq(0, 10, 1))
```

Generally, mean C values were normally distributed with few extreme outliers, suggesting we can use a linear model to predict mean c as a function of treatment and year. 

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

# A couple of outliers in the NAT treatment but likely alright since the variablity in outcomes seems to be a characteristic of NAT

# Only one extreme value in LE 2021 (likely because of DALCAN and VIOPED)
Summary_table %>%
  group_by(Treatment, Year) %>%
  identify_outliers(Mean_C)


# Mean C fits a normal distribution

Summary_table  %>%
  group_by(Treatment, Year) %>%
  shapiro_test(Mean_C)

ggplot(data = Summary_table , aes(x= Mean_C)) +geom_histogram(bins =15) 


# Vast majority of points fall along the reference line

ggqqplot(Summary_table , "Mean_C", ggtheme = theme_bw()) +
  facet_grid(Year~ Treatment, labeller = "label_both")

```

#### Mean C - Model fitting


I used a linear model to predict mean c as a function of seeding treatment, year, and an interaction between treatment and year. A mixed model using block as a random effect produced a singular fit because the variance explained by the random effect block was estimated as close to zero and did not further inform the data. Therefore, I chose to use the simpler model. 

Model fit was high, with an adjusted $R^{2}$ value of 0.687. Also, residual plots did not reveal any concerning patterns.

```{r, echo = FALSE, message = FALSE}



# Dropped the mixed model due to singular fit -> the variance of the random effect block is estimated close to zero and does not further inform the data. 

Summary_table$Block <- as.factor(Summary_table$Block)

Summary_table$Treatment <- factor(Summary_table$Treatment, levels=c("LE", "LL", "NAT", "NON" , "SIM"))


# Normal interaction model


### Interaction was n.s.

# Mean_C.mod.lm.interaction <- lm(Mean_C~Treatment*Year, data =Summary_table)

 Mean_C.mod.lm.additive <- lm(Mean_C~Treatment+Year, data =Summary_table)

## Summary results

summary( Mean_C.mod.lm.additive )

```


```{r}
# Residual plot looks decent
plot(Mean_C.mod.lm.additive)

```

Analysis of variance (type III) revealed that seeding treatment was the only significant factor influence mean c value. 

```{r, echo = FALSE, message = FALSE}
## ANOVA type 3

Anova(Mean_C.mod.lm.additive, type = 3)
```

Posthoc analysis indicated that all seeding treatments increased mean c value compared to unseeded plots. Seeding all species in one addition produced more conservative communities than treatments that seeded summer dispersing species first followed by fall dispersing species. Even though seeding only the fall dispersing species first produced higher quality communities than those that seeded species with natural timing, there was no difference in mean c between the seeding treatments that had two lumped additions. 

```{r}
Mean_C.mod.lm.est <- lm(Mean_C~Treatment, data =Summary_table)


est.lm.treatment_treatment <- emmeans::emmeans(Mean_C.mod.lm.est, ~ Treatment, type = "response")

pairs(est.lm.treatment_treatment, adjust = "tukey")


#Posthoc test
#est.lm.treatment <- emmeans::emmeans(Mean_C.mod.lm.interaction, ~ Treatment*Year, type = "response")

#pairs(est.lm.treatment, adjust = "tukey")

```


#### Mean C -  Figures


Overall, seeding fall dispersing species early either as part of one simultaneous or as two lumped additions produced the highest quality communities. 


```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

Summary_table_lumped <- Summary_table %>% 
  group_by(Treatment, Year) %>%   
  summarise(Mean_C_t = mean(Mean_C), SD_C = sd(Mean_C), mean_richness = mean(Species_richness), SD_richness = sd(Species_richness), mean_Shannon = mean(Shannon), SD_Shannon = sd(Shannon))
  
Summary_table_lumped <- Summary_table_lumped %>% 
rename(Treatment = Treatment, "C_Mean" = Mean_C_t, "C_SD" = SD_C, "SR_Mean" = mean_richness,"SR_SD" = SD_richness, "SDI_Mean" = mean_Shannon, "SDI_SD" = SD_Shannon )

```

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

Summary_table_lumped$Treatment <- factor(Summary_table_lumped$Treatment, levels=c("NON", "NAT", "LE", "LL", "SIM"))

Summary_table$Treatment <- factor(Summary_table$Treatment, levels=c("NON", "NAT", "LE", "LL", "SIM"))

lower.c.treatment <- Summary_table_lumped$C_Mean - Summary_table_lumped$C_SD
upper.c.treatment <- Summary_table_lumped$C_Mean + Summary_table_lumped$C_SD

C.plot_treatment <-   ggplot()+
  geom_jitter(data = Summary_table, aes(x = Treatment, y = Mean_C, fill = Treatment, shape = Treatment), alpha = 0.8, size = 3)+
    geom_errorbar(data = Summary_table_lumped, aes(x = Treatment, y = C_Mean, ymin = lower.c.treatment , ymax = upper.c.treatment), width = 0.35, size = .75)+
geom_point(data = Summary_table_lumped, size = 4.5, aes(x = Treatment, y = C_Mean, shape = Treatment), fill = "black")+
  labs(y = "Mean C", x = "" )+
  theme_classic() +
  theme(text=element_text(size=18), legend.key.size=unit(1, "cm"), legend.position="none",  axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 14), axis.text.y = element_text(size = 14))+
  scale_x_discrete(breaks = c("LE", "LL", "NAT", "NON", "SIM"),  labels = c("Summer first", "Fall first", "Natural", "No seeding", "Simultaneous"))+
  scale_fill_manual(name = "Treatment", breaks = c("LE", "LL", "NAT", "NON", "SIM"),  labels = c("Summer first", "Fall first", "Natural", "No seeding", "Simultaneous"), values = c("#009E73", "#56B4E9",  "#F0E442","#E69F00", "#0072B2"))+
scale_shape_manual(name = "Treatment", breaks = c("LE", "LL", "NAT", "NON", "SIM"), labels = c("Summer first", "Fall first", "Natural", "No seeding", "Simultaneous"), values=c(21, 22,23, 24, 25))+
  ylim(0,4)



C.plot_treatment
```


```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

set.seed(5)
 C.plot_treatment <- C.plot_treatment + 
  annotate("text", x = 1, y = 1.5, label = "a",
           fontface =2, size = 5) +
   annotate("text", x = 2, y = 3, label = "b",
            fontface =2, size = 5) +
   annotate("text", x = 3 , y = 3, label = "bc",
            fontface =2, size = 5) +
   annotate("text", x = 4, y = 3.25, label = "cd",
            fontface =2, size = 5) +
     annotate("text", x = 5, y =3.75, label = "d",
              fontface =2, size = 5)
```

### Species Richness {.tabset}


SIM treatments had the greatest species richness compared to all other treatments, while NON and NAT had the lowest. 

#### SR - Model assumptions

Overall, species richness follows a normal distribution despite being count data. There were a couple of outliers in the natural seeding treatment but this is likely alright. 

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

Summary_table_lumped <- Summary_table_lumped %>% 
  filter(Treatment != "NON")

Summary_table <- Summary_table %>% 
  filter(Treatment != "NON")

# A couple of outliers in the NAT treatment but likely alright since the variability in outcomes seems to be a characteristic of NAT

Summary_table %>%
  group_by(Treatment, Year) %>%
  identify_outliers(Species_richness)


# Species richness fits a normal distribution

Summary_table %>%
  group_by(Treatment, Year) %>%
  shapiro_test(Species_richness)

ggplot(data = Summary_table, aes(x= Species_richness)) +geom_histogram(bins =15) 


# Vast majority of points fall along the reference line

ggqqplot(Summary_table, "Species_richness", ggtheme = theme_bw()) +
  facet_grid(Year~ Treatment, labeller = "label_both")


```


#### SR - Model fitting

I chose to use a linear mixed-effects model with block as a random effect to predict species richness as a function of seeding treatment, year, and an interaction between treatment and year. Despite being count data, the distribution of species richness is remarkably balanced and not skewed. Model comparison using AIC revealed that the Normal model performed better than the Poisson model, which was underdispersed. A more complicated Quasipoisson model that accounted for underdispersion produced similar results to the Normal mixed model. Therefore, I chose to use the less complicated Normal model.

Overall, model fit was decent. For example, $R^{2}_{GLMM(m)}$ (i.e., the variance explained by only the fixed effects) was 0.474 and $R^{2}_{GLMM(c)}$ (i.e., variance explained by the entire model) was 0.598. Inclusion of the random effect block substantially improved model fit. Furthermore, there were no strange patterns or occurrences in the model residuals.  


```{r, echo = FALSE,  message = FALSE, warning = FALSE}

# Model Fitting


SR.mod.normal <- lmer(Species_richness~Treatment+Year+(1|Block), data =Summary_table)
summary(SR.mod.normal)

## Marginal R^2 (variance explained by ONLY fixed effects) = 0.47437
## Conditional R^2 (variance explained by the entire model) = 0.5975126

## Inclusion of the random effect increased model fit 

## interaction n.s.

r.squaredGLMM(SR.mod.normal)
```


```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

# Residual plot looks decent except for one large outlier
plot(SR.mod.normal)

```

A type III ANOVA revealed significant differences in species richness between years and seeding treatments. However, there was no significant interactive effect between year and seeding treatment on species richness. 

Seeding treatments that added species either in one or two lumped additions had significantly greater species richness than unseeded plots. Multiple seedings according to natural dispersal activity did not increase species richness compared to unseeded plots.  Adding the entire species pool simultaneously produced communities with the greatest species richness.  Treatments that conducted multiple seedings resulted in communities possessing similar amounts of species richness regardless of timing and order of species arrival. 

```{r, echo = FALSE,  message = FALSE, warning = FALSE}

## Treatment and Year significant
## Interaction between Treatment and Year not significant

Anova(SR.mod.normal, type = 3)


SR.mod.normal.est <- lmer(Species_richness~Treatment+(1|Block), data =Summary_table)


est.lmer.SR.treatment <- emmeans::emmeans(SR.mod.normal.est, ~ Treatment, type = "response")

#Posthoc test

## Treatment



pairs(est.lmer.SR.treatment, adjust = "tukey")

#Posthoc test

## Treatment x Year

#est.lmer.SR.treatment_Year <- emmeans::emmeans(SR.mod.normal, ~ Treatment*Year, type = "response")

#pairs(est.lmer.SR.treatment_Year, adjust = "tukey")


```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}

# Poisson Model

# SR.mod.pois <- glmer(Species_richness~Treatment+Year+(1|Block),family = "poisson", data =Summary_table)
# summary(SR.mod.pois)
# Anova(SR.mod.pois, type = 3)

# Check dispersion

## Underdispersed! 0.659 
## Interaction between treatment and year are not significant

# Dispersion_glmer(SR.mod.pois)


# Not accounting for the underdispersion mattered a lot! .

## Used a quassipoisson model instead and year is significant

#m6 <-glmmPQL(Species_richness~Treatment+Year,
             # random = ~ 1 | Block,
             # family = quasipoisson(link='log'), 
             # data = Summary_table)

# summary(m6)
# Anova(m6, type = 3)

```



#### SR - Figures

Overall, seeding all species at the same time produced communities with the greatest species richness. For the most part, seeding increased species richness

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}
set.seed(5)

Summary_table_lumped$Treatment <- factor(Summary_table_lumped$Treatment, levels=c("NAT", "LE", "LL", "SIM"))

Summary_table$Treatment <- factor(Summary_table$Treatment, levels=c("NAT", "LE", "LL", "SIM"))

lower.sr.treatment <- Summary_table_lumped$SR_Mean - Summary_table_lumped$SR_SD
upper.sr.treatment <- Summary_table_lumped$SR_Mean + Summary_table_lumped$SR_SD

sr.plot_treatment <-   ggplot()+
  geom_jitter(data = Summary_table, 
              aes(x = Year, y = Species_richness, group = Treatment, 
                  fill = Treatment, shape = Treatment),
              alpha = 0.8, size = 3.5, position = position_jitterdodge(dodge.width = 0.75))+
  geom_errorbar(data = Summary_table_lumped, 
                aes(x = Year, group = Treatment,
                    y = SR_Mean, ymin = lower.sr.treatment , ymax = upper.sr.treatment), 
                position= position_dodge(width = .85), width = 0.5, size = 0.75,
                show_guide=FALSE)+
  geom_point(data = Summary_table_lumped, 
             size = 4.5, aes(x = Year, y = SR_Mean, group = Treatment, 
                             fill = Treatment, shape = Treatment),
             fill = "black", position= position_dodge(width = 0.85),
             show_guide=FALSE)+
  labs(y = "Total richness", x = "" )+
  theme_classic() +
  theme(text=element_text(size=18), 
        legend.key.size=unit(0.5, "cm"),
        legend.position="right", 
        axis.text.x = element_text(size = 16),
        axis.text.y = element_text(size = 16))+
  scale_fill_manual(name = "",
                    breaks = c("LE", "LL", "NAT", "SIM"),  
                    labels = c("Summer first", "Fall first", "Natural","Simultaneous"), 
                    values = c("#009E73", "#56B4E9",  "#F0E442", "#0072B2"))+
  scale_shape_manual(name = "",
                   breaks = c("LE", "LL", "NAT", "SIM"),
                   labels = c("Summer first", "Fall first", "Natural", "Simultaneous"), 
                   values=c(21, 22,23, 25))+
  scale_y_continuous(breaks = seq(10, 30, by = 5),
                     limits = c(10, 33))


sr.plot_treatment <- sr.plot_treatment +
  annotate("text", x = 1.2, y = 33, label = "Treatment: p < 0.001***",
           fontface =2, size = 4)+
  annotate("text", x = .96, y = 31.5, label = "Year: p < 0.05*",
           fontface =2, size = 4)


```


```{r, echo = FALSE,  message = FALSE, warning = FALSE}
# set.seed(5)
# sr.plot_treatment  <- sr.plot_treatment  + annotate("text", x = 1, y = 22, label = "a",
#            fontface =2, size = 5) +
#    annotate("text", x = 2, y = 24.5, label = "b",
#             fontface =2, size = 5) +
#    annotate("text", x = 3 , y = 27.5, label = "bc",
#             fontface =2, size = 5) +
#    annotate("text", x = 4, y = 27.5, label = "cd",
#             fontface =2, size = 5) +
#      annotate("text", x = 5, y =31, label = "d",
#               fontface =2, size = 5)

```


#### Summer-Dispersing 


```{r}
### Filter out everything that isn't a seeded summer-dispersing species

inner_long <- inner_wide %>% 
  gather(key = "SPP6", value = "max_cover", ACAVIR:VIOPED) 

Sown_species_ID <- left_join(inner_long,  species_list_PE)

SR_summer <- Sown_species_ID  %>% 
  group_by(Block, Treatment, Year) %>% 
  filter(Seeded == "Summer" & max_cover > 0 & Treatment != "NON") %>% 
  summarize(Summer_SR = n_distinct(SPP6))


SR_summer_zero <- Sown_species_ID  %>% 
  group_by(Block, Treatment, Year) %>% 
  filter(Seeded == "Summer" & Treatment != "NON") %>% 
  summarise(max_cover = sum(max_cover))
  
SR_summer_zero <- SR_summer_zero  %>% 
  filter(max_cover == 0) 


SR_summer_zero <- SR_summer_zero [,c(1,2,3)]
SR_summer_zero$Summer_SR <- rep(0, nrow(SR_summer_zero))


SR_summer_all <- full_join(SR_summer,SR_summer_zero)

```


```{r, echo = FALSE,  message = FALSE, warning = FALSE}

# Model Fitting


SR.summer.mod.normal <- lmer(Summer_SR~Treatment+Year+(1|Block), data =
SR_summer_all)
summary(SR.summer.mod.normal)

## Marginal R^2 (variance explained by ONLY fixed effects) = 
## Conditional R^2 (variance explained by the entire model) = 

## Inclusion of the random effect increased model fit 

## interaction n.s.

r.squaredGLMM(SR.summer.mod.normal)



```

```{r}

Anova(SR.summer.mod.normal, type = 3)


SR.summer.mod.normal.est <- lmer(Summer_SR~Treatment+(1|Block), data =
SR_summer_all)


est.lmer.SR.summer.treatment <- emmeans::emmeans(SR.summer.mod.normal.est, ~ Treatment, type = "response")

pairs(est.lmer.SR.summer.treatment , adjust = "tukey")
```



```{r}
set.seed(7)

SR_summer_all_mean_sd <- SR_summer_all %>% 
  group_by(Treatment, Year) %>% 
  summarize(mean_SR_summer = mean(Summer_SR), sd_SR_summer = sd(Summer_SR))



SR_summer_all_mean_sd$Treatment <- factor(SR_summer_all_mean_sd$Treatment, levels=c("NAT", "LE", "LL", "SIM"))

SR_summer_all$Treatment <- factor(SR_summer_all$Treatment, levels=c("NAT", "LE", "LL", "SIM"))

sr.summer.plot_treatment <-   ggplot()+
  geom_jitter(data = SR_summer_all, 
              aes(x = Year, y = Summer_SR, fill = Treatment, 
                  shape = Treatment, group = Treatment), 
              alpha = 1, size = 3.5, 
              position = position_jitterdodge(dodge.width = 0.85))+
  geom_errorbar(data = SR_summer_all_mean_sd,
                aes(x = Year, y = mean_SR_summer,  group = Treatment, 
                    ymin = mean_SR_summer - sd_SR_summer, 
                    ymax = mean_SR_summer + sd_SR_summer), 
                position = position_dodge(width = 0.85), width = .5,
                size = 0.75)+
  geom_point(data = SR_summer_all_mean_sd, size = 4.5, 
             aes(x = Year, y = mean_SR_summer, 
                 shape = Treatment,  group = Treatment), 
             position = position_dodge2(width = 0.85),
             fill = "black")+
  labs(y = "Sown summer richness", x = "" )+
  theme_classic() +
  theme(text=element_text(size=18), 
        legend.key.size=unit(1, "cm"),
        legend.position="none",  
        axis.text.x = element_text(size = 16), 
        axis.text.y = element_text(size = 16))+
  scale_fill_manual(name = "Treatment",
                    breaks = c("LE", "LL", "NAT", "SIM"),  
                    labels = c("Summer first", "Fall first", "Natural", "Simultaneous"), 
                    values = c("#009E73", "#56B4E9",  "#F0E442", "#0072B2"))+
  # scale_x_discrete(breaks = c("LE", "LL", "NAT", "SIM"),
  #                  labels = c("Summer first", "Fall first", "Natural", "Simultaneous"))+
  scale_shape_manual(name = "Treatment", 
                     breaks = c("LE", "LL", "NAT", "SIM"), 
                     labels = c("Summer first", "Fall first", "Natural", "Simultaneous"),
                     values=c(21, 22,23, 25))+
  scale_y_continuous(breaks = seq(0, 20, by = 5),
                     limits = c(-0.75, 20))




sr.summer.plot_treatment <- sr.summer.plot_treatment +
  annotate("text", x = 1.2, y = 20, label = "Treatment: p < 0.001***",
           fontface = 2, size = 4)

```




#### Fall-Dispersing 


```{r}
### Filter out everything that isn't a seeded fall-dispersing species

SR_fall <- Sown_species_ID  %>% 
  filter(Seeded == "Fall" & max_cover > 0 & Treatment != "NON") %>% 
  summarize(Fall_SR = n_distinct(SPP6))


SR_fall_zero <- Sown_species_ID %>% 
  group_by(Block, Treatment, Year) %>% 
  filter(Seeded == "Fall"  & Treatment != "NON") %>% 
  summarise(max_cover = sum(max_cover))
  
SR_fall_zero <- SR_fall_zero  %>% 
  filter(max_cover == 0) 


SR_fall_zero <- SR_fall_zero[,c(1,2,3)]
SR_fall_zero$Fall_SR <- rep(0, nrow(SR_fall_zero))


SR_fall_all <- full_join(SR_fall,SR_fall_zero)


```


```{r, echo = FALSE,  message = FALSE, warning = FALSE}

# Model Fitting


SR.fall.mod.normal <- lm(Fall_SR~Treatment+Year, data = SR_fall_all)
summary(SR.fall.mod.normal)

## Marginal R^2 (variance explained by ONLY fixed effects) = 
## Conditional R^2 (variance explained by the entire model) = 

## Inclusion of the random effect increased model fit 

## interaction n.s.



```

```{r}

Anova(SR.fall.mod.normal , type = 3)


SR.fall.mod.normal.est <- lm(Fall_SR~Treatment, data = SR_fall_all)


est.lmer.SR.fall.treatment <- emmeans::emmeans(SR.fall.mod.normal.est, ~ Treatment, type = "response")

pairs(est.lmer.SR.fall.treatment , adjust = "tukey")
```



```{r}
set.seed(5)

SR_fall_all_mean_sd <- SR_fall_all %>% 
  group_by(Treatment, Year) %>% 
  summarize(mean_SR_fall = mean(Fall_SR), sd_SR_fall = sd(Fall_SR))



SR_fall_all_mean_sd $Treatment <- factor(SR_fall_all_mean_sd $Treatment, levels=c("NAT", "LE", "LL", "SIM"))

SR_fall_all$Treatment <- factor(SR_fall_all$Treatment, levels=c("NAT", "LE", "LL", "SIM"))

sr.fall.plot_treatment <-   ggplot()+
    geom_jitter(data = SR_fall_all,
              aes(x = Year, y = Fall_SR, fill = Treatment, shape = Treatment, group = Treatment), 
              alpha = 0.8, size = 3.5,
              position = position_jitterdodge(dodge.width = 0.85))+
    geom_errorbar(data = SR_fall_all_mean_sd, 
                  aes(x = Year, y = mean_SR_fall, ymin = mean_SR_fall - sd_SR_fall, 
                      ymax = mean_SR_fall + sd_SR_fall, group = Treatment),
                  position = position_dodge(width = 0.85), width = .5, size = 0.75) +
    geom_point(data = SR_fall_all_mean_sd, size = 4.5, 
               aes(x = Year, y = mean_SR_fall, shape = Treatment, group = Treatment), 
               fill = "black", position = position_dodge(width = 0.85))+
    labs(y = "Sown fall richness", x = "" ) +
    theme_classic() +
    theme(text=element_text(size=18), 
          legend.key.size=unit(1, "cm"),
          legend.position="none",  
          axis.text.x = element_text(size = 16), 
          axis.text.y = element_text(size = 16))+
    scale_fill_manual(name = "Treatment", 
                      breaks = c("LE", "LL", "NAT", "SIM"), 
                      labels = c("Summer first", "Fall first", "Natural", "Simultaneous"), 
                      values = c("#009E73", "#56B4E9",  "#F0E442", "#0072B2"))+
    scale_shape_manual(name = "Treatment", 
                       breaks = c("LE", "LL", "NAT", "SIM"),
                       labels = c("Summer first", "Fall first", "Natural", "Simultaneous"),
                       values=c(21, 22,23, 25))+
  scale_y_continuous(breaks = seq(0, 20, by = 5),
                     limits = c(-0.75, 20))



sr.fall.plot_treatment  <- sr.fall.plot_treatment +
  annotate("text", x = 1.2, y = 20, label = "Treatment: p < 0.001***",
           fontface = 2, size = 4)

```



#### Unsown


```{r}
### Filter out everything that isn't a seeded fall-dispersing species

SR_unsown_all <- Sown_species_ID  %>% 
  filter(Seeded == "Unseeded" & max_cover > 0 & Treatment != "NON") %>% 
  summarize(unsown_SR = n_distinct(SPP6))


```


```{r, echo = FALSE,  message = FALSE, warning = FALSE}

# Model Fitting


SR.unsown.mod.normal <- lmer(unsown_SR~Treatment+Year+(1|Block), data = SR_unsown_all)
summary(SR.unsown.mod.normal)

## Marginal R^2 (variance explained by ONLY fixed effects) = 
## Conditional R^2 (variance explained by the entire model) = 

## Inclusion of the random effect increased model fit 

## interaction n.s.



```

```{r}

Anova(SR.unsown.mod.normal , type = 3)


```



```{r}
set.seed(5)

SR_unsown_all_mean_sd <- SR_unsown_all %>% 
  group_by(Treatment, Year) %>% 
  summarize(mean_SR_unsown = mean(unsown_SR), sd_SR_unsown = sd(unsown_SR))



SR_unsown_all_mean_sd $Treatment <- factor(SR_unsown_all_mean_sd $Treatment, levels=c("NAT", "LE", "LL", "SIM"))

SR_unsown_all$Treatment <- factor(SR_unsown_all$Treatment, levels=c("NAT", "LE", "LL", "SIM"))

sr.unsown.plot_treatment <-   ggplot()+
    geom_jitter(data = SR_unsown_all,
              aes(x = Year, y = unsown_SR, fill = Treatment, shape = Treatment, group = Treatment), 
              alpha = 0.8, size = 3.5,
              position = position_jitterdodge(dodge.width = 0.85))+
    geom_errorbar(data = SR_unsown_all_mean_sd, 
                  aes(x = Year, y = mean_SR_unsown, ymin = mean_SR_unsown - sd_SR_unsown, 
                      ymax = mean_SR_unsown + sd_SR_unsown, group = Treatment),
                  position = position_dodge(width = 0.85), width = .5, size = 0.75) +
    geom_point(data = SR_unsown_all_mean_sd, size = 4.5, 
               aes(x = Year, y = mean_SR_unsown, shape = Treatment, group = Treatment), 
               fill = "black", position = position_dodge(width = 0.85))+
    labs(y = "Unsown richness", x = "" ) +
    theme_classic() +
    theme(text=element_text(size=18), 
          legend.key.size=unit(1, "cm"),
          legend.position="none",  
          axis.text.x = element_text(size = 16), 
          axis.text.y = element_text(size = 16))+
    scale_fill_manual(name = "Treatment", 
                      breaks = c("LE", "LL", "NAT", "SIM"), 
                      labels = c("Summer first", "Fall first", "Natural", "Simultaneous"), 
                      values = c("#009E73", "#56B4E9",  "#F0E442", "#0072B2"))+
    scale_shape_manual(name = "Treatment", 
                       breaks = c("LE", "LL", "NAT", "SIM"),
                       labels = c("Summer first", "Fall first", "Natural", "Simultaneous"),
                       values=c(21, 22,23, 25))+
  scale_y_continuous(breaks = seq(0, 20, by = 5),
                     limits = c(-0.75, 20))


sr.unsown.plot_treatment

```




### Shannon Diversity Index   {.tabset}

#### SDI - Model assumptions

SIM and LL treatments had the greatest Shannon diversity index value while NON had the lowest. NAT and LE appear comparable. 


```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

# Two extreme outliers (one in NAT 2021 and another in SIM 2021)
Summary_table %>%
  group_by(Treatment, Year) %>%
  identify_outliers(Shannon)


# Except for one point, Shannon diversity fits a normal distribution

Summary_table %>%
  group_by(Treatment, Year) %>%
  shapiro_test(Shannon)

ggplot(data = Summary_table, aes(x= Shannon)) +geom_histogram(bins =15) 


# Vast majority of points fall along the reference line

ggqqplot(Summary_table, "Shannon", ggtheme = theme_bw()) +
  facet_grid(Year~ Treatment, labeller = "label_both")


```

#### SDI - Model fitting

```{r, echo = FALSE, message = FALSE, warning = FALSE}

Shannon.lmer.mod <- lmer(Shannon~Treatment+Year+(1|Block), data =Summary_table)
summary(Shannon.lmer.mod)
Anova(Shannon.lmer.mod, type = 3)

# No significant interaction between treatment and year


## Marginal R^2 (variance explained by ONLY fixed effects) = 0.330704
## Conditional R^2 (variance explained by the entire model) = 0.3844412

## Inclusion of the random effect increased model fit 

r.squaredGLMM(Shannon.lmer.mod)



# Post-Hoc comparison


est.lmer.SDI.treatment <- emmeans::emmeans(Shannon.lmer.mod, ~ Treatment, type = "response")


#Posthoc test

## Treatment
pairs(est.lmer.SDI.treatment, adjust = "tukey")

```


```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

# A little heteroscedastic (bowtie shaped but probably ok)

plot(Shannon.lmer.mod)

```

#### SDI - Figures

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

Summary_table_lumped$Treatment <- factor(Summary_table_lumped$Treatment, levels=c("NON", "NAT", "LE", "LL", "SIM"))

Summary_table$Treatment <- factor(Summary_table$Treatment, levels=c("NON", "NAT", "LE", "LL", "SIM"))

lower.sdi.treatment <- Summary_table_lumped$SDI_Mean - Summary_table_lumped$SDI_SD
upper.sdi.treatment <- Summary_table_lumped$SDI_Mean + Summary_table_lumped$SDI_SD

sdi.plot_treatment <-   ggplot()+
  geom_jitter(data = Summary_table, aes(x = Treatment, y = Shannon, fill = Treatment, shape = Treatment), alpha = 0.8, size = 3)+
    geom_errorbar(data = Summary_table_lumped, aes(x = Treatment, y = SDI_Mean, ymin = lower.sdi.treatment , ymax = upper.sdi.treatment), width = 0.35, size = .75)+
geom_point(data = Summary_table_lumped, size = 4.5, aes(x = Treatment, y = SDI_Mean, shape = Treatment), fill = "black")+
  labs(y = "SDI", x = "" )+
  theme_classic() +
  theme(text=element_text(size=16), legend.key.size=unit(1, "cm"), legend.position="none",  axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 14), axis.text.y = element_text(size = 14))+
  scale_x_discrete(breaks = c("LE", "LL", "NAT", "NON", "SIM"),  labels = c("Summer first", "Fall first", "Natural", "No seeding", "Simultaneous"))+
  scale_fill_manual(name = "Treatment", breaks = c("LE", "LL", "NAT", "NON", "SIM"),  labels = c("Summer first", "Fall first", "Natural", "No seeding", "Simultaneous"), values = c("#009E73", "#56B4E9",  "#F0E442","#E69F00", "#0072B2"))+
scale_shape_manual(name = "Treatment", breaks = c("LE", "LL", "NAT", "NON", "SIM"), labels = c("Summer first", "Fall first", "Natural", "No seeding", "Simultaneous"), values=c(21, 22,23, 24, 25))



sdi.plot_treatment 
```


```{r, echo = FALSE,  message = FALSE, warning = FALSE}
set.seed(5)
sdi.plot_treatment <- sdi.plot_treatment  +
  annotate("text", x = 1, y = 2.2, label = "a",
           fontface =2, size = 5) +
   annotate("text", x = 2, y = 2.6, label = "ab",
            fontface =2, size = 5) +
   annotate("text", x = 3 , y = 2.6, label = "bc",
            fontface =2, size = 5) +
   annotate("text", x = 4, y = 2.75, label = "bc",
            fontface =2, size = 5) +
     annotate("text", x = 5, y =2.85, label = "c",
              fontface =2, size = 5)
```

### Plot Panel {.tabset}

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 10, fig.height = 4.5}
set.seed(5)
diversity_panel <- ggarrange(C.plot_treatment, sr.plot_treatment , sdi.plot_treatment ,
align='h', labels=c('A', 'B','C'), ncol = 3, font.label = list(size = 16), vjust = 1)

diversity_panel
```

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 10, fig.height = 4.5}

richness_panel <- ggarrange(sr.plot_treatment, sr.summer.plot_treatment, sr.fall.plot_treatment,
align='h', labels=c('A', 'B','C'), ncol = 3,
common.legend = T, legend = "bottom")

richness_panel
```

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 10, fig.height = 10.5}
# set.seed(5)
# richness_panel <- ggarrange(sr.plot_treatment, NULL, 
#                             ggarrange(sr.summer.plot_treatment, sr.fall.plot_treatment, sr.unsown.plot_treatment, ncol = 3, labels = c("B)", "C)", "D"), hjust=.5, vjust = 1), labels = c("A)", ""), nrow = 2,  hjust=.5, vjust = 1)+
#   theme(plot.margin = margin(1,1,1,1, "cm"))
# 
# richness_panel 


# plot_grid(prop_immigrant_seeds_cover_rain.plot,  prop_immigrant_seedlings_rain_bank.plot, prop_immigrant_seedlings_cover_bank.plot, prop_new_species_cover_rain.plot , prop_new_species_rain_bank.plot,prop_new_species_cover_bank.plot, hjust=.5, vjust = 1, ncol = 3, labels = c("A)", "B)", "C)", "D)", "E)", "F)"), label_size = 18, align = 'v') +theme(plot.margin = margin(1,1,1,1, "cm"))

# 
# total_panel <- ggarrange(sr.plot_treatment, NULL, nrow = 1, ncol = 2, hjust=.5, vjust = 1, labels = c("A)", ""), widths = c(1, 0.25))
#                             
# richness_panel <- ggarrange(sr.summer.plot_treatment, sr.fall.plot_treatment, ncol = 2, labels = c("B)", "C)", "D"), hjust=.5, vjust = 1)
#   
# All_together_panel <- ggarrange(total_panel , richness_panel, nrow = 2)+
#   theme(plot.margin = margin(1,1,1,1, "cm"))
# 
# All_together_panel
# 


```




## Question 2: Does timing of species arrival influence seeded cover? {.tabset}


**note** some of the species used in the seed mix were present in the seed bank at my study site (e.g., RUDHIR and PENDIG). Additionally, some spillover occurred with seeded species seeding into other treatments like NON (e.g., BIDARI)

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

#inner_wide is the community matrix
#inner_wide.labs has the labels

inner_long <- inner_wide %>% 
  gather(key = "SPP6", value = "max_cover", ACAVIR:VIOPED) 

```

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

### Make a dataset that includes only species that were seeded

Seeded <- inner_long  %>% 
  filter(Treatment %in% c("LE", "NAT", "LL", "SIM", "NON")) %>% 
  filter(SPP6 %in% c("ACHMIL","CORLAN", "LOBSPI","TRAOHI", "LINSUL", "CORPAL", "AMOCAN", "DALCAN", "DALPUR", "SPHOBT", "CARBUS", "KOEMAC",  "HEURIC", "VIOPED", "SISCAM", "DODMEA", "MELVIR", "PACPLA", "LESCAP","MONFIS", "BIDARI","SORNUT", "SCHSCO", "HYPPUN", "SPOHET", "HELMOL", "RATPIN", "SOLRIG", "PENDIG", "CHAFAS",  "ERYYUC", "CORTRI", "PYCTEN", "CROSAG", "RUDHIR", "LIAPYC"))


### Make a dataset that includes only species that were not seeded

Non_Seeded <- inner_long  %>% 
  filter(Treatment %in% c("LE", "NAT", "LL", "SIM", "NON")) %>% 
  filter(!SPP6 %in% c("ACHMIL","CORLAN", "LOBSPI","TRAOHI", "LINSUL", "CORPAL", "AMOCAN", "DALCAN", "DALPUR", "SPHOBT", "CARBUS", "KOEMAC",  "HEURIC", "VIOPED", "SISCAM", "DODMEA", "MELVIR", "PACPLA", "LESCAP","MONFIS", "BIDARI","SORNUT", "SCHSCO", "HYPPUN", "SPOHET", "HELMOL", "RATPIN", "SOLRIG", "PENDIG", "CHAFAS",  "ERYYUC", "CORTRI", "PYCTEN", "CROSAG", "RUDHIR", "LIAPYC"))
```

```{r}
Seeded2 <- Seeded %>% filter(Year == "2023") %>% filter(max_cover > 0) 
unique(Seeded2$SPP6)
```

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

#Sum the total cover of seeded species per treatment.block.year

Seeded_Tot <- Seeded %>% 
  filter(Treatment != "NON") %>% 
  group_by(Treatment, Block, Year) %>% 
  summarise(seeded_cover = sum(max_cover))

# Sum the total cover observed at a treatment, block, and year

Cover_Tot <- inner_long %>% 
  filter(Treatment != "NON") %>% 
  group_by(Treatment, Block, Year) %>% 
  summarise(tot_cover = sum(max_cover))

# Join the two dataset together

Total_Cover_Tot <- full_join(Seeded_Tot, Cover_Tot)

# Make a new column for the proportion of seeded cover

Total_Cover_Tot$Seeded_prop <- Total_Cover_Tot$seeded_cover / Total_Cover_Tot$tot_cover 

#Take the mean cover for each treatment

Seeded_Mean <- Total_Cover_Tot %>% 
  group_by(Treatment, Year) %>% 
  summarise(Mean_seeded_prop = mean(Seeded_prop), SD = sd(Seeded_prop))

```


### Total Seeded Cover


#### TSC - Model fitting

```{r, echo = FALSE,  message = FALSE, warning = FALSE}

## I removed the random effect block because it had no effect on the model fit and explained no additional variance. (chose the most parsimonious model)

# No interaction between year and treatment 
# Random effect does not increase the amount of variance explained and results in singular fit

Binom_mod <- glm(cbind(seeded_cover, tot_cover) ~ Treatment*Year, family = binomial, data = Total_Cover_Tot)
summary(Binom_mod)

Anova(Binom_mod, type = 3)

## posthoc test
pairs(emmeans::emmeans(Binom_mod , ~ Treatment*Year, type = "response", adjust = "tukey"))

pairs(emmeans::emmeans(Binom_mod , ~ Treatment, type = "response", adjust = "tukey"))
pairs(emmeans::emmeans(Binom_mod , ~ Year, type = "response", adjust = "tukey"))
```

```{r, echo = FALSE, message = FALSE, warning = FALSE}

## residuals look decent

plot(Binom_mod)
```


#### TSC - Figures

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

# #Re-order the levels
# Seeded_Mean$Treatment <- factor(Seeded_Mean$Treatment, levels=c("NAT", "LE", "LL", "SIM"))
# 
# total.cover.plot <- ggplot(data = Seeded_Mean, aes(x = Year,  y = Mean_seeded_prop, fill = Treatment))+
#   geom_bar(position = position_dodge(preserve = "single"), stat = "identity", color = "black", show.legend = TRUE)+
#   geom_errorbar(position =  position_dodge(width = 0.9, preserve = "single"), 
#                 aes(x = Year, ymax=Mean_seeded_prop+SD, ymin = Mean_seeded_prop), size = .75)  +
#   scale_fill_manual(name = "Treatment",
#                     breaks = c("NAT", "LE", "LL", "SIM"),
#                     labels = c("Natural","Summer first", "Fall first",  "Simultaneous"), 
#                     values=c("#F0E442",  "#009E73", "#56B4E9", "#0072B2"))+
#   labs(x = "Year", y = "Prop. seeded cover")+
#   theme_minimal()+
#   theme()+ 
#   scale_y_continuous(breaks=seq(0,.70,by=0.1), limits = c(0,.7))+
#   theme_classic() +
#   theme(text=element_text(size=16), axis.text.x = element_text(size = 14), axis.text.y= element_text(size = 14))
# 
# total.cover.plot 

```


```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

#Re-order the levels
Seeded_Mean$Treatment <- factor(Seeded_Mean$Treatment, levels=c("NAT", "LE", "LL", "SIM"))
Total_Cover_Tot$Treatment <- factor(Total_Cover_Tot$Treatment, levels=c("NAT", "LE", "LL", "SIM"))

total.cover.plot  <- ggplot()+
  geom_jitter(data = Total_Cover_Tot,
              aes(x = Year, y = Seeded_prop, fill = Treatment, shape = Treatment, group = Treatment), 
              alpha = 0.8, size = 3.5,
              position = position_jitterdodge(dodge.width = 0.85))+
  geom_point(data = Seeded_Mean, size = 4.5,
             aes(x = Year, y = Mean_seeded_prop, group = Treatment, shape = Treatment),
             position = position_dodge2(width = 0.85), fill = "black", show_guide=FALSE)+
  geom_errorbar(data = Seeded_Mean, 
               aes(x = Year, ymax=Mean_seeded_prop+SD, ymin = Mean_seeded_prop-SD, group = Treatment), 
                position =  position_dodge(width = 0.85), width = 0.5, size = .75, show_guide=FALSE)+ 
  scale_fill_manual(name = "",
                    breaks = c("LE", "LL", "NAT", "SIM"),
                    labels = c("Summer first", "Fall first", "Natural", "Simultaneous"), 
                    values=c( "#009E73", "#56B4E9", "#F0E442","#0072B2"))+
  scale_shape_manual(name = "", 
                       breaks = c("LE", "LL", "NAT", "SIM"),
                       labels = c("Summer first", "Fall first", "Natural", "Simultaneous"),
                       values=c(21, 22, 23, 25)) +
  labs(x = "Year", y = "Prop. seeded cover")+
  theme(axis.text=element_text(size=16), axis.title = element_text(size = 12))+
  scale_y_continuous(breaks = seq(0, .8, by = .1),
                     limits = c(-0.02, .8))+
  theme_classic() +
  theme(text=element_text(size=16), axis.text.x = element_text(size = 14), axis.text.y= element_text(size = 14))


total.cover.plot <- total.cover.plot +
  annotate("text", x = 1.2, y = .8, label = "Treatment: p < 0.001***",
           fontface =2, size = 4)+
  annotate("text", x = 1.03, y = .75, label = "Year: p < 0.001***",
           fontface =2, size = 4)+
  annotate("text", x = .94, y = .7, label = "TxY: p < 0.05*",
           fontface =2, size = 4)
```

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

# total.cover.plot  <- total.cover.plot  +
#    annotate("text", x = .67, y = 0.18, label = "a",
#            fontface =2, size = 5) +
#    annotate("text", x = 0.9, y = 0.21 , label = "a",
#             fontface =2, size = 5) +
#    annotate("text", x = 1.12 , y = 0.38, label = "b",
#             fontface =2, size = 5) +
#    annotate("text", x = 1.335 , y = 0.53, label = "b",
#             fontface =2, size = 5) +
#      annotate("text", x = 1.67, y =0.24, label = "a",
#               fontface =2,size = 5) +
#    annotate("text", x = 1.9, y = 0.40, label = "c",
#             fontface =2, size = 5) +
#    annotate("text", x = 2.12, y = 0.50, label = "bd",
#             fontface =2, size = 5) +
#    annotate("text", x = 2.335, y = 0.67, label = "d",
#             fontface =2, size = 5) 
```




### Seeded cover of summer dispersing species

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

# Make a dataset containing only species you seeded that disperse in the summer

Seeded_early <- inner_long  %>% 
  filter(Treatment != "NON") %>% 
  filter(SPP6 %in% c("ACHMIL","CORLAN", "LOBSPI","TRAOHI", "LINSUL", "CORPAL", "AMOCAN", "DALCAN", "DALPUR", "SPHOBT", "CARBUS", "KOEMAC",  "HEURIC", "VIOPED", "SISCAM", "DODMEA", "MELVIR", "PACPLA"))
```


```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}


Seeded_early_all <- Seeded_early %>% 
  group_by(Treatment, Year, Block) %>% 
  summarise(seeded_cover = sum(max_cover))


# Join the two dataset together

Total_Cover_Early <- full_join(Seeded_early_all, Cover_Tot)

# Make a new column for the proportion of summer dispersing seeded cover


Total_Cover_Early$Seeded_prop <-Total_Cover_Early$seeded_cover / Total_Cover_Early$tot_cover

# Obtain the mean and standard deviation for summer dispersing seeded cover


Seeded_early_all_mean <- Total_Cover_Early %>% 
  filter(Treatment != "NON") %>% 
  group_by(Treatment, Year) %>% 
  summarise(Mean_cover = mean(Seeded_prop), SD = sd(Seeded_prop)) 
```



#### ESC - Model fitting


```{r, echo = FALSE, message = FALSE, warning = FALSE}

## I removed the random effect block because it had no effect on the model fit and explained no additional variance. (chose the most parsimonius model)

# no interaction between year and treatment 
# Random effect does not increase the amount of variance explained and results in singular fit

Binom_mod_early <- glm(cbind(seeded_cover, tot_cover) ~ Treatment+Year, family = binomial, data = Total_Cover_Early)

summary(Binom_mod_early)
Anova(Binom_mod_early, type = 3)


## Posthoc tests


Binom_mod_early.est <- glm(cbind(seeded_cover, tot_cover) ~ Treatment+Year, family = binomial, data = Total_Cover_Early)

pairs(emmeans::emmeans(Binom_mod_early.est, ~ Treatment, type = "response", adjust = "tukey"))
pairs(emmeans::emmeans(Binom_mod_early.est, ~ Year, type = "response",  adjust = "tukey"))
```

```{r, echo = FALSE, message = FALSE, warning = FALSE}
## not the most normal residuals...

plot(Binom_mod_early)
```


#### ESC - Figures

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}
# #Re-order the levels
# Seeded_early_all_mean$Treatment <- factor(Seeded_early_all_mean$Treatment, levels=c( "NAT", "LE", "LL", "SIM"))
# 
# early.cover.plot <-ggplot(data = Seeded_early_all_mean, aes(x = Year,  y = Mean_cover, fill = Treatment))+
#   geom_bar(position = position_dodge(preserve = "single"), stat = "identity", color = "black", show.legend =  TRUE)+
#   geom_errorbar(position =  position_dodge(width = 0.9, preserve = "single"), aes(x = Year, ymax=Mean_cover+SD, ymin = Mean_cover), size = .75)+
#   scale_fill_manual(name = "Treatment",
#                     breaks = c("NAT", "LE", "LL", "SIM"),
#                     labels = c("Natural","Summer first", "Fall first",  "Simultaneous"), 
#                     values=c("#F0E442",  "#009E73", "#56B4E9","#0072B2"))+
#   labs(x = "Year", y = "Prop. seeded summer cover")+
#   theme_minimal()+
#   theme(axis.text=element_text(size=16), axis.title = element_text(size = 12))+ 
#   scale_y_continuous(breaks=seq(0, 0.7 ,by=.1), limits = c(0,0.7))+
#   theme(legend.position = "none")+
#   theme_classic()  +
#   theme(text=element_text(size=16), axis.text.x = element_text(size = 14), axis.text.y= element_text(size = 14))
#   
# early.cover.plot
```


```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

#Re-order the levels
Seeded_early_all_mean$Treatment <- factor(Seeded_early_all_mean$Treatment, levels=c("NAT", "LE", "LL", "SIM"))
Total_Cover_Early$Treatment <- factor(Total_Cover_Early$Treatment, levels=c("NAT", "LE", "LL", "SIM"))

early.cover.plot <- ggplot()+
  geom_jitter(data = Total_Cover_Early,
              aes(x = Year, y = Seeded_prop, fill = Treatment, shape = Treatment, group = Treatment), 
              alpha = 0.8, size = 3.5,
              position = position_jitterdodge(dodge.width = 0.85))+
  geom_point(data = Seeded_early_all_mean, size = 4.5,
             aes(x = Year, y = Mean_cover, group = Treatment, shape = Treatment),
             position = position_dodge2(width = 0.85), fill = "black", show_guide=FALSE)+
  geom_errorbar(data = Seeded_early_all_mean, 
               aes(x = Year, ymax=Mean_cover+SD, ymin = Mean_cover-SD, group = Treatment), 
                position =  position_dodge(width = 0.85), width = 0.5, size = .75, show_guide=FALSE)+ 
  scale_fill_manual(name = "",
                    breaks = c("LE", "LL", "NAT", "SIM"),
                    labels = c("Summer first", "Fall first", "Natural", "Simultaneous"), 
                    values=c( "#009E73", "#56B4E9", "#F0E442","#0072B2"))+
  scale_shape_manual(name = "", 
                       breaks = c("LE", "LL", "NAT", "SIM"),
                       labels = c("Summer first", "Fall first", "Natural", "Simultaneous"),
                       values=c(21, 22, 23, 25)) +
  labs(x = "Year", y = "Prop. seeded summer cover")+
  theme(axis.text=element_text(size=16), axis.title = element_text(size = 12))+
  scale_y_continuous(breaks = seq(0, .7, by = .1),
                     limits = c(-0.02, .7))+
  theme_classic() +
  theme(text=element_text(size=16), axis.text.x = element_text(size = 14), axis.text.y= element_text(size = 14))


early.cover.plot <- early.cover.plot +
  annotate("text", x = 1.2, y = .7, label = "Treatment: p < 0.001***",
           fontface =2, size = 4)+
  annotate("text", x = 1.03, y = .65, label = "Year: p < 0.001***",
           fontface =2, size = 4)
```


```{r, echo = FALSE, message = FALSE, warning = FALSE}


 # early.cover.plot <- early.cover.plot +
 #   annotate("text", x = .67, y = 0.07, label = "ad",
 #           fontface =2, size = 5) +
 #   annotate("text", x = 0.9, y = 0.12 , label = "b",
 #            fontface =2, size = 5) +
 #   annotate("text", x = 1.12 , y = 0.045, label = "a",
 #            fontface =2, size = 5) +
 #   annotate("text", x = 1.335 , y = 0.12, label = "b",
 #            fontface =2, size = 5) +
 #     annotate("text", x = 1.67, y =0.095, label = "d",
 #              fontface =2, size = 5) +
 #   annotate("text", x = 1.9, y = 0.295, label = "c",
 #            fontface =2, size = 5) +
 #   annotate("text", x = 2.12, y = 0.055, label = "ad",
 #            fontface =2,size = 5) +
 #   annotate("text", x = 2.335, y = 0.21, label = "e",
 #            fontface =2, size = 5) 
```


### Fall dispersing species only

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

Seeded_late <- inner_long  %>% 
  filter(Treatment %in% c("LE", "NAT", "LL", "SIM")) %>% 
  filter(SPP6 %in% c("LESCAP","MONFIS", "BIDARI","SORNUT", "SCHSCO", "HYPPUN", "SPOHET", "HELMOL", "RATPIN", "SOLRIG", "PENDIG", "CHAFAS",  "ERYYUC", "CORTRI", "PYCTEN", "CROSAG", "RUDHIR", "LIAPYC"))
```



```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}


Seeded_late_all <- Seeded_late %>% 
  group_by(Treatment, Year, Block) %>% 
  summarise(seeded_cover = sum(max_cover)) 

# Join the two dataset together

Total_Cover_Late <- full_join(Seeded_late_all, Cover_Tot)

Total_Cover_Late$Seeded_prop <-Total_Cover_Late$seeded_cover / Total_Cover_Late$tot_cover

Seeded_late_all_mean <-Total_Cover_Late %>% 
  group_by(Treatment, Year) %>% 
  summarise(Mean_cover = mean(Seeded_prop), SD = sd(Seeded_prop)) 
```


#### LSC - Model fitting


```{r, echo = FALSE, message = FALSE, warning = FALSE}

## I removed the random effect block because it had no effect on the model fit and explained no additional variance. (chose the most parsimonius model)

# no interaction between year and treatment 
# Random effect does increase the amount of variance explained

Binom_mod_late <- glmer(cbind(seeded_cover, tot_cover) ~ Treatment+Year+(1|Block), family = binomial, data = Total_Cover_Late)

summary(Binom_mod_late)
Anova(Binom_mod_late, type = 3)


Binom_mod_late.est <- glmer(cbind(seeded_cover, tot_cover) ~ Treatment+Year+(1|Block), family = binomial, data = Total_Cover_Late)

pairs(emmeans::emmeans(Binom_mod_late.est, ~ Treatment, type = "response", adjust = "tukey"))
pairs(emmeans::emmeans(Binom_mod_late.est, ~ Year, type = "response", adjust = "tukey"))
```

```{r, echo = FALSE, message = FALSE, warning = FALSE}
plot(Binom_mod_late)
```


#### LSC - Figures


```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}
# #Re-order the levels
# Seeded_late_all_mean$Treatment <- factor(Seeded_late_all_mean$Treatment, levels=c("NAT", "LE", "LL", "SIM"))
# 
# late.cover.plot <- ggplot(data = Seeded_late_all_mean, aes(x = Year,  y = Mean_cover, fill = Treatment))+
#   geom_bar(position = position_dodge(preserve = "single"), stat = "identity", color = "black", show.legend = TRUE)+
#   geom_errorbar(position =  position_dodge(width = 0.9, preserve = "single"), aes(x = Year, ymax=Mean_cover+SD, ymin = Mean_cover), size = .75)+ scale_fill_manual(name = "Treatment",
#                     breaks = c("NAT", "LE", "LL", "SIM"),
#                     labels = c("Natural","Summer first", "Fall first",  "Simultaneous"), 
#                     values=c("#F0E442",  "#009E73", "#56B4E9",
#                              "#0072B2"))+
#   labs(x = "Year", y = "Prop. seeded fall cover")+
#   theme(axis.text=element_text(size=16), axis.title = element_text(size = 12))+ 
#   scale_y_continuous(breaks=seq(0, 0.7,by=.1), limits = c(0,0.7))+
#   theme_classic() +
#   theme(text=element_text(size=16), axis.text.x = element_text(size = 14), axis.text.y= element_text(size = 14))
# 
# 
# late.cover.plot
```


```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

#Re-order the levels
Seeded_late_all_mean$Treatment <- factor(Seeded_late_all_mean$Treatment, levels=c("NAT", "LE", "LL", "SIM"))
Total_Cover_Late$Treatment <- factor(Total_Cover_Late$Treatment, levels=c("NAT", "LE", "LL", "SIM"))

late.cover.plot <- ggplot()+
  geom_jitter(data = Total_Cover_Late,
              aes(x = Year, y = Seeded_prop, fill = Treatment, shape = Treatment, group = Treatment), 
              alpha = 0.8, size = 3.5,
              position = position_jitterdodge(dodge.width = 0.85))+
  geom_point(data = Seeded_late_all_mean, size = 4.5,
             aes(x = Year, y = Mean_cover, group = Treatment, shape = Treatment),
             position = position_dodge2(width = 0.85), fill = "black", show_guide=FALSE)+
  geom_errorbar(data = Seeded_late_all_mean, 
               aes(x = Year, ymax=Mean_cover+SD, ymin = Mean_cover-SD, group = Treatment), 
                position =  position_dodge(width = 0.85), width = 0.5, size = .75, show_guide=FALSE)+ 
  scale_fill_manual(name = "",
                    breaks = c("LE", "LL", "NAT", "SIM"),
                    labels = c("Summer first", "Fall first", "Natural", "Simultaneous"), 
                    values=c( "#009E73", "#56B4E9", "#F0E442","#0072B2"))+
  scale_shape_manual(name = "", 
                       breaks = c("LE", "LL", "NAT", "SIM"),
                       labels = c("Summer first", "Fall first", "Natural", "Simultaneous"),
                       values=c(21, 22, 23, 25)) +
  labs(x = "Year", y = "Prop. seeded fall cover")+
  theme(axis.text=element_text(size=16), axis.title = element_text(size = 12))+
  scale_y_continuous(breaks = seq(0, .7, by = .1),
                     limits = c(-0.01, .7))+
  theme_classic() +
  theme(text=element_text(size=16), axis.text.x = element_text(size = 14), axis.text.y= element_text(size = 14))


late.cover.plot <- late.cover.plot+
  annotate("text", x = 1.2, y = .7, label = "Treatment: p < 0.001***",
           fontface =2, size = 4)+
  annotate("text", x = .98, y = .65, label = "Year: p < 0.01**",
           fontface =2, size = 4)
```




```{r, echo = FALSE,  message = FALSE, warning = FALSE}

# late.cover.plot <- late.cover.plot +
#    annotate("text", x = .67, y = 0.18, label = "a",
#           fontface =2, size = 5) +
#    annotate("text", x = 0.9, y = 0.165 , label = "a",
#             fontface =2, size = 5) +
#    annotate("text", x = 1.12 , y = 0.38, label = "b",
#             fontface =2, size = 5) +
#   annotate("text", x = 1.335 , y = 0.50, label = "b",
#             fontface =2, size = 5) +
#      annotate("text", x = 1.67, y =0.23, label = "a",
#               fontface =2, size = 5) +
#    annotate("text", x = 1.9, y = 0.18, label = "a",
#             fontface =2, size = 5) +
#    annotate("text", x = 2.12, y = 0.50, label = "b",
#             fontface =2, size = 5) +
#    annotate("text", x = 2.335, y = 0.54, label = "b",
#             fontface =2, size = 5) 
```


### Plot Panel

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 10, fig.height = 4.5}

seeded_cover_panel <- ggarrange(total.cover.plot, early.cover.plot, late.cover.plot,
align='h', labels=c('A', 'B','C'), ncol = 3,
common.legend = T, legend = "bottom")

seeded_cover_panel
```

### Species specific differences

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
Seeded_early2 <- Seeded_early %>% 
  # only look at the last year
  filter(Year == "2023") %>% 
  # only look at species found in the last year
  filter(SPP6 %in% c("ACHMIL","CORLAN", "KOEMAC", "VIOPED")) %>% 
  filter(Treatment %in% c("LE", "LL")) %>% 
  spread(key = "Treatment", value = "max_cover") 


# For summer dispersing species, subtract LE (added first) - LL (added second) in the same block. Positive values means they had greater cover when added first, zero = no difference, and negative means greater cover when added second. 


Seeded_early2$difference <- Seeded_early2$LE - Seeded_early2$LL



Seeded_late2 <- Seeded_late %>% 
  # only look at the last year
  filter(Year == "2023") %>% 
  # only look at species found in the last year
  filter(SPP6 %in% c("LESCAP","MONFIS", "BIDARI","SORNUT", "HELMOL", "RATPIN", "PENDIG", "CHAFAS",  "ERYYUC", "CORTRI", "RUDHIR")) %>% 
  filter(Treatment %in% c("LE", "LL")) %>% 
  spread(key = "Treatment", value = "max_cover") 


# For fall dispersing species, subtract LL (added first) - LE (added second) in the same block. Positive values means they had greater cover when added first, zero = no difference, and negative means greater cover when added second. 

Seeded_late2$difference <- Seeded_late2$LL - Seeded_late2$LE

test <- full_join(Seeded_early2, Seeded_late2)

test2 <- left_join(test, species_list_PE)


# Is the difference between added early and added late equal to 0 or significantly different from zero? 

# If = 0, timing does not affect cover
# If > 0, priority increases cover on average
# If < 0, priority decreases cover on average

# One sample t test 
t.test(test2$difference)



ggplot(data = test2, aes(x= difference)) +geom_density()


lower_ci <- function(mean, se, n, conf_level = 0.95){
  lower_ci <- mean - qt(1 - ((1 - conf_level) / 2), n - 1) * se
}
upper_ci <- function(mean, se, n, conf_level = 0.95){
  upper_ci <- mean + qt(1 - ((1 - conf_level) / 2), n - 1) * se
}


test3 <- test2 %>% 
  group_by(SPP6) %>%
  summarise(smean = mean(difference, na.rm = TRUE),
            ssd = sd(difference, na.rm = TRUE),
            count = n()) %>%
  mutate(se = ssd / sqrt(count),
         lower_ci = lower_ci(smean, se, count),
         upper_ci = upper_ci(smean, se, count))

```

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 10, fig.height = 6}

# Overall priority increased cover at the species level. However, this was mostly driven by a couple of dominate species including grey-headed coneflower, common yarrow, Indian grass, and June grass, and tall tickseed. 

ggplot()+
  geom_point(data = test3, aes(x = fct_reorder(SPP6, smean),  y = smean), size = 3)+
  geom_jitter(data = test2, aes(x = SPP6, y = difference, color = Seeded), size = 2.5, alpha = 0.9) +
  geom_point(data = test3, aes(x = fct_reorder(SPP6, smean),  y = smean), size = 2.5)+
  geom_errorbar(data = test3, aes(x= SPP6, ymin = lower_ci , ymax = upper_ci), width = 0.4, size = 1) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey20") +
  ylim(-20, 42)+
  theme_classic()+
  labs(x = "Species", y = "Difference in cover (first - second)")+
  annotate("text", x = 4, y = 40, label = "Greater cover when sown first", fontface = 2, size = 5)+
  annotate("text", x = 12, y = -20, label = "Greater cover when sown second", fontface = 2, size = 5)+
  theme(
  text = element_text(size = 16, family = "Arial"),
  axis.text = element_text(size = 14),
  axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
  axis.title = element_text(size = 16),
  legend.title = element_text(size = 16),
  legend.text = element_text(size = 16),
  )+
  scale_color_manual(name = "Dispersal Guild", breaks = c("Fall", "Summer"),
                         labels = c("Fall", "Summer"),
                        values = c( "#56B4E9", "#009E73"))


 

```





##  Question 3: Does timing of species arrival influence species composition? - Bray-Curtis {.tabset}



```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

### set a basic theme 

BioR.theme <- theme(
panel.background = element_blank(),
panel.border = element_blank(),
panel.grid = element_blank(),
axis.line = element_line("gray25"),
text = element_text(size = 18, family="Arial"),
axis.text = element_text(size = 18, colour = "gray25"),
axis.title = element_text(size = 18, colour = "gray25", face = "bold"),
legend.title = element_text(size = 18, face = "bold"),
legend.text = element_text(size = 18),
legend.key = element_blank())

```



### Year: 2022




```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}

#Make a wide formatted dataset
inner_wide_2022 <- inner_cover_max_reduced_lumped  %>%
  filter(Year %in% 2022 & Treatment != "NON") %>% 
  group_by(Block, Treatment, SPP6) %>% 
  summarize(max_cover = sum(max_cover)) %>% 
  spread(key="SPP6", value="max_cover") 

#Replace NA values with 0

inner_wide_2022[is.na(inner_wide_2022)] <- 0 

#Turn our dataset into a matrix 
inner_wide_mat_2022 <- inner_wide_2022[,-c(1,2)]


# labels
inner_wide_labels_2022 <- inner_wide_2022[,c(1,2)]

## Bare ground dataset
inner_bare_cover_2022 <- inner_bare_cover %>% 
  filter(Year == "2022") %>% 
  filter(Treatment != "NON" & Treatment != "EMP") %>% 
   rename("Bare_cover" = "max_cover") %>% 
  select(-SPP6)

## Light dataset

light_2022 <- light_fall_2022 %>% 
  filter(Treatment != "EMP" & Treatment!= "NON") %>% 
  group_by(Block, Treatment, Location) %>% 
  summarize(Mean_Light = mean(Light))  %>% 
  spread(key = Location , value = Mean_Light)

## join

env.data.2022.bare <- full_join(inner_wide_labels_2022, inner_bare_cover_2022) 

env.data.2022 <- full_join(env.data.2022.bare, light_2022) 

env.data.2022 <- env.data.2022 %>% 
 unite(UniqueBlock, c(Treatment,Block), sep = "_", remove = FALSE)




row.names(inner_wide_mat_2022 ) <- env.data.2022$UniqueBlock
inner_wide_mat_2022 <- data.matrix(inner_wide_mat_2022 )



# Standardize by max 

inner.hel.2022 <- decostand(inner_wide_mat_2022, "hellinger")


```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
### fit a distance-based RDA 
#### Allows you to do a constrained ordination using non-Euclidean distance measures such as Bray-curtis dissimilarity (which is fitting for our data on plant communities)

#### it works by: 1) making the distance matrix based on your desired measure, 2) doing a PCoA, 3) taking the PCoA eigenvectors and putting them into an RDA.


### Use the capscale function (not the dbRDA since it doesn't provide species scores)

## Light and bare ground were not important predictors



dbRDA.22 <- capscale(inner.hel.2022 ~ Treatment, data =env.data.2022 ,  dist="bray", add = TRUE)

## dbRDA results
dbRDA.22

env.data.2022$Block <- as.factor(env.data.2022$Block)

## PERMANOVA results

anova(dbRDA.22, step = 1000, by = "terms", permu = 999)


### Pair-wise comparisons

BiodiversityR::multiconstrained(method = "capscale", inner.hel.2022  ~ Treatment, data = env.data.2022, by = "term", dist="bray", add = TRUE)

```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
### Get the basic ordination plot 

plot1 <- ordiplot(dbRDA.22, choices = c(1,2))
```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
### extract the site information

sites.long1 <- sites.long(plot1, env.data = env.data.2022)

head(sites.long1)

### extract the species information

species.long1 <- species.long(plot1)
species.long1

### extract the first two axis info

axis.long1 <- axis.long(dbRDA.22, choices = c(1,2))
axis.long1 
```




```{r, echo = FALSE,  message = FALSE, warning = FALSE}
# Do an envfit to find influential speicies (p < 0.05)


spec.envfit1 <- envfit(plot1, env=inner.hel.2022)
spec.data.envfit1 <- data.frame(r=spec.envfit1$vectors$r, p=spec.envfit1$vectors$pvals)
species.long1 <- species.long(plot1, spec.data=spec.data.envfit1)
species.long1


species.long.1 <- species.long1[species.long1$p < 0.01, ]
species.long.1

# Join influential species dataframe to species list information so we can later color species labels by seeded status

species.long.1 <- species.long.1 %>% 
  rename(SPP6 = "labels")

species.long.1 <- left_join(species.long.1, species_list_PE, by = "SPP6")
```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
# Get the vector information for environmental variables

#vectors.envfit.22 <- envfit(plot1, env=env.data.2022)
#vectors.long.1 <- vectorfit.long(vectors.envfit.22 )
#vectors.long.1

```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
# Get the ellipse information

ordiplot(dbRDA.22, choices = c(1,2))
Treatment.ellipses.22 <- ordiellipse(plot1, groups=env.data.2022$Treatment, display="sites", kind="sd")
Treatment.ellipses.22.1 <- ordiellipse.long(Treatment.ellipses.22 , grouping.name="Treatment")
```

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 10, fig.height = 10}

# Plot it!


dbRDA.2022.plot <- ggplot() + 
    geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
    geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +  
    xlab(axis.long1[1, "label"]) +
    ylab(axis.long1[2, "label"]) +  
    scale_fill_manual(name = "Treatment", breaks = c("LE", "LL", "NAT", "SIM"),
                         labels = c("Summer first", "Fall first", "Natural", "Simultaneous"),
                         values = c("#009E73", "#56B4E9",  "#F0E442", "#0072B2"))+
    scale_shape_manual(name = "Treatment", breaks = c("LE", "LL", "NAT", "SIM"),
                         labels = c("Summer first", "Fall first", "Natural", "Simultaneous"),
                         values = c(21, 22, 23, 25))+
  geom_polygon(data=Treatment.ellipses.22.1, 
                   aes(x=axis1, y=axis2, fill=Treatment, alpha = 0.1), 
              size=0.2, show.legend=FALSE) +
  geom_point(data=sites.long1, 
               aes(x=axis1, y=axis2, fill=Treatment, shape=Treatment), 
               size=4.5) +
  geom_segment(data=species.long.1, 
                 aes(x=0, y=0, xend=axis1*4, yend=axis2*4), 
                 colour="grey0", size=.8, alpha = 0.4) +
  scale_color_manual(name = "Species", breaks = c("Fall", "Summer", "Unseeded"),
                         labels = c("Seeded fall dispersing", "Seeded summer dispersing", "Unseeded"),
                         values = c("darkblue", "#003c00",  "#444444"))+
    geom_label_repel(data=species.long.1, aes(x=axis1*4, y=axis2*4, colour=Seeded, label=SPP6), size = 4.5,
                   alpha = 0.5, 
                   label.padding=.1, 
                   na.rm=TRUE,
                   seed = 1234) +
    geom_label_repel(data=species.long.1, 
                    aes(x=axis1*4, y=axis2*4, colour=Seeded, label=SPP6), size =  4.5,
                   alpha = 1, 
                   label.padding=.1, 
                   fill = NA,
                   na.rm=TRUE,
                   seed = 1234) +
    BioR.theme  +
    coord_fixed(ratio=1)+
  annotate("text", x = -1.10, y = 2, label = "Y1: 2022", size = 7, fontface =2)

dbRDA.2022.plot

```


### 2022 NMDS

```{r, results = 'hide', echo = FALSE, message = FALSE, warning = FALSE, fig.show='hide'}

# Check the number of dimensions needed for the NMDS  (write the result of this test)

library(goeveg)
## Bray-Curtis dissimilarity
dimcheckMDS(inner.hel.2022, distance = "bray", k=6, trymax= 50, autotransform = FALSE)

###
## *** Best solution with three dimensions
```

```{r, echo = FALSE, results = 'hide', echo = FALSE, message = FALSE, warning = FALSE}
set.seed(5)
Bray_NMDS_2022 <- metaMDS(inner.hel.2022, distance = "bray", k=3, try=1000, trymax = 1000, autotransform =  FALSE)
```

```{r, results = 'hide', message = FALSE, echo = FALSE, warning = FALSE}
set.seed(5)
### Looks at which species were the most influential in driving the observed patterns

inner.spp.fit <- envfit(Bray_NMDS_2022, inner.hel.2022, permutations = 5000, k = 3)

#head(inner.spp.fit)


```

```{r, results = 'hide', message = FALSE, echo = FALSE, warning = FALSE, fig.show='hide'}

# Make a grouping variable so I can match site names to the NMDS output
site = c(rep(c("LE", "LL", "NAT", "SIM"), 6))

# Put the NMDS scores into it's own dataframe 
scrs <- as.data.frame(scores(Bray_NMDS_2022, display = "sites"))

# Match the NMDS scores to the right site labels
scrs <- cbind(scrs, site)

# Extracts the required scaling factor for the vector arrows
arrow_factor <- ordiArrowMul(inner.spp.fit)

# Take the envfit model and convert into a a dataframe (scaled)
spp.scrs <- as.data.frame(scores(inner.spp.fit, display = "vectors"))*arrow_factor

# Add the p values, R squared values to the envit model species score dataframe
spp.scrs <- cbind(spp.scrs, Species = rownames(spp.scrs), Pvalues = inner.spp.fit$vectors$pvals, R_squared = inner.spp.fit$vectors$r)


# Subset out species that had a p value <= 0.001 (since I think env fit truncates to 0.001)
spp.scrs.01 <- subset(spp.scrs, Pvalues < 0.01)

spp.scrs.01 <- tibble::rownames_to_column(spp.scrs.01, "SPP6")

species.long.1 <- left_join(spp.scrs.01, species_list_PE, by = "SPP6")

```

```{r, results = 'hide', message = FALSE, echo = FALSE, warning = FALSE, fig.show='hide'}

# Only including this plot because I need to call the plot in order to obtain the ordiellipse object

plot(Bray_NMDS_2022$points, xlim = c(-2, 2), ylim = c(-2, 2), col = alpha(0.5), xlab = "NMDS1", ylab = "NMDS2", cex.lab = 1.25, cex.axis = 1.25, bty="n")


# Store the ordiellipse data into a list
site.ellipses <- ordiellipse(Bray_NMDS_2022, groups = site, display = "sites", kind = "se", conf = 0.95)


# Convert the ordiellipse data into a dataframe that I can plot in ggplot
site.ellipses.long2 <- ordiellipse.long(site.ellipses, grouping.name="site")
```



```{r, results = 'hide', message = FALSE, echo = FALSE, warning = FALSE, fig.width = 8, fig.height = 8}

library(ggnewscale)

# Plot the species scores + the NMDS results

NMDS_plot_2022 <- ggplot(scrs) +
  geom_point(mapping = aes(x = NMDS1, y = NMDS2, 
                      fill = site, shape = site),
             size=2.5, alpha = 0.8) + 
  new_scale_color()+
  scale_shape_manual(name = "Treatment", 
                     values=c(21, 22,23, 25),
                     breaks=c("LE", "LL", "NAT", "SIM"),
                     labels = c("Summer first", "Fall first",
                                "Natural", "Simultaneous")) +
  scale_fill_manual(name = "Treatment",
                    values=c("#009E73", "#56B4E9",  "#F0E442","#0072B2"),
                    breaks=c("LE", "LL", "NAT", "SIM"), 
                    labels = c("Summer first", "Fall first",
                                "Natural", "Simultaneous")) +
  coord_fixed() +
  geom_segment(data = species.long.1, 
              aes(x = 0, xend = NMDS1 * arrow_factor, y = 0,
                  yend = NMDS2* arrow_factor),
                  arrow = arrow(length = unit(0.2, "cm")), 
                  color = "#888888", alpha = 0.7) +
  geom_text_repel(data = species.long.1,
                  aes(x = NMDS1 * arrow_factor, 
                      y = NMDS2 * arrow_factor,
                      label = Scientific_Name, color = Seeded),  
                      size = 3, max.overlaps = getOption("ggrepel.max.overlaps", default = 50) ) +
  scale_color_manual(name = "Species",
                     values=c("darkblue", "#003c00",  "#444444"),
                     breaks=c("Fall", "Summer", "Unseeded"), 
                     labels = c("Fall", "Summer", "Unseeded"))+
  new_scale_color()+
  geom_polygon(data = site.ellipses.long2, 
               aes(x = axis1, y=axis2, color = site, 
                   fill =   after_scale(alpha(color, 0.2))), 
               size = 0.2, show.legend = FALSE) +
   scale_color_manual(name = "Treatment",
                    values=c("#009E73", "#56B4E9",  "#F0E442","#0072B2"),
                    breaks=c("LE", "LL", "NAT", "SIM"), 
                    labels = c("Summer first", "Fall first",
                                "Natural", "Simultaneous"))+
  annotate("text", x = -.67, y = 1,
           label = "bold(Stress) == 0.12", parse = TRUE)+
  annotate("text", x = -.8, y = .9, 
           label = "bold(K) == 3", parse = TRUE) +
  theme_classic() +
  theme(text=element_text(size=18), 
        legend.key.size=unit(0.5, "cm"),
        legend.position = "right")+
  scale_y_continuous(breaks = seq(-0.5, 1, by = .5),
                     limits = c(-0.8, 1))+
  scale_x_continuous(breaks = seq(-0.8, .8, by = .4),
                     limits = c(-1, .8))


NMDS_plot_2022
```


```{r}
adonis2(inner.hel.2022 ~ Treatment, data = env.data.2022,  dist="bray")

### Pair-wise comparisons
library(pairwiseAdonis)
pairwise.adonis2(inner.hel.2022 ~ Treatment, data = env.data.2022, p.adjust = "bonferroni")

```


### Year: 2023

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 12, fig.height = 4}

#Make a wide formatted dataset
inner_wide_2023 <- inner_cover_max_reduced_lumped  %>%
  filter(Year %in% 2023 & Treatment != "NON") %>% 
  spread(key="SPP6", value="max_cover") 

#Replace NA values with 0

inner_wide_2023[is.na(inner_wide_2023)] <- 0 

#Turn our dataset into a matrix 
inner_wide_mat_2023 <- inner_wide_2023[,-c(1,2,3)]

# make new dataset for labels & envdata

## get the treatment labels
inner_wide_labels_2023 <- inner_wide_2023[,c(1,2,3)]

## Bare ground dataset
inner_bare_cover_2023 <- inner_bare_cover %>% 
  filter(Year == "2023" & Treatment != "NON") %>% 
   rename("Bare_cover" = "max_cover") %>% 
  select(-SPP6)

## Light dataset

light_2023 <- light_fall_2023 %>% 
  group_by(Block, Treatment, Location) %>% 
  filter(Treatment != "NON") %>% 
  summarize(Mean_Light = mean(Light)) %>% 
  spread(key = Location , value = Mean_Light)

## join

env.data.2023.bare <- full_join(inner_wide_labels_2023, inner_bare_cover_2023) 

env.data.2023 <- full_join(env.data.2023.bare, light_2023)



env.data.2023 <- env.data.2023 %>% 
 unite(UniqueBlock, c(Treatment,Block), sep = "_", remove = FALSE)


row.names(inner_wide_mat_2023 ) <- env.data.2023$UniqueBlock
inner_wide_mat_2023 <- data.matrix(inner_wide_mat_2023 )



# Standardize by max 

inner.hel.2023 <- decostand(inner_wide_mat_2023, "hellinger")

```


```{r, echo = FALSE,  message = FALSE, warning = FALSE}
### fit a distance-based RDA 
#### Allows you to do a constrained ordination using non-Euclidean distance measures such as Bray-curtis dissimilarity (which is fitting for our data on plant communities)

#### it works by: 1) making the distance matrix based on your desired measure, 2) doing a PCoA, 3) taking the PCoA eigenvectors and putting them into an RDA.


### Use the capscale function (not the dbRDA since it doesn't provide species scores)
dbRDA <- capscale(inner.hel.2023 ~ Treatment, data = env.data.2023,  dist="bray", add = TRUE)

## dbRDA results
dbRDA

## PERMANOVA results
anova(dbRDA, step = 1000, by = "terms", permu = 999)

### Pair-wise comparisons

BiodiversityR::multiconstrained(method = "capscale", inner.hel.2023 ~ Treatment, data = env.data.2023,  dist="bray", add = TRUE)
```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
### Get the basic ordination plot 

plot2 <- ordiplot(dbRDA, choices = c(1,2))
```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
### extract the site information

sites.long2 <- sites.long(plot2, env.data = env.data.2023)

head(sites.long2)

### extract the species information

species.long2 <- species.long(plot2)
species.long2

### extract the first two axis info

axis.long2 <- axis.long(dbRDA, choices = c(1,2))
axis.long2 
```



```{r, echo = FALSE,  message = FALSE, warning = FALSE}
# Do an envfit to find influential speicies (p < 0.05)


spec.envfit <- envfit(plot2, env=inner.hel.2023)
spec.data.envfit <- data.frame(r=spec.envfit$vectors$r, p=spec.envfit$vectors$pvals)
species.long2 <- species.long(plot2, spec.data=spec.data.envfit)
species.long2


species.long3 <- species.long2[species.long2$p < 0.01, ]
species.long3

# Join influential species dataframe to species list information so we can later color species labels by seeded status

species.long3 <- species.long3 %>% 
  rename(SPP6 = "labels")

species.long3 <- left_join(species.long3, species_list_PE, by = "SPP6")



```



```{r, echo = FALSE,  message = FALSE, warning = FALSE}
# Get the ellipse information

ordiplot(dbRDA, choices = c(1,2))
Treatment.ellipses <- ordiellipse(plot2, groups=env.data.2023$Treatment, display="sites", kind="sd")
Treatment.ellipses.long2 <- ordiellipse.long(Treatment.ellipses, grouping.name="Treatment")
```

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 10, fig.height = 10}

# Plot it!


dbRDA.2023.plot <- ggplot() + 
    geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
    geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +  
    xlab(axis.long2[1, "label"]) +
    ylab(axis.long2[2, "label"]) +  
   # scale_x_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +
   # scale_y_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +  
    scale_fill_manual(name = "Treatment", breaks = c("LE", "LL", "NAT", "NON", "SIM"),
                         labels = c("Summer first", "Fall first", "Natural", "No seeding", "Simultaneous"),
                         values = c("#009E73", "#56B4E9",  "#F0E442","#E69F00", "#0072B2"))+
    scale_shape_manual(name = "Treatment", breaks = c("LE", "LL", "NAT", "NON", "SIM"),
                         labels = c("Summer first", "Fall first", "Natural", "No seeding", "Simultaneous"),
                         values = c(21, 22, 23, 24, 25))+
    geom_polygon(data=Treatment.ellipses.long2, 
                   aes(x=axis1, y=axis2, fill=Treatment, alpha = 0.1), 
              size=0.2, show.legend=FALSE) +
  geom_point(data=sites.long2, 
               aes(x=axis1, y=axis2, fill=Treatment, shape=Treatment), 
               size=4.5) +
  geom_segment(data=species.long3, 
                 aes(x=0, y=0, xend=axis1*4, yend=axis2*4), 
                 color="grey0", size=0.8, alpha = 0.4) +
    geom_label_repel(data=species.long3, aes(x=axis1*4, y=axis2*4, color=Seeded, label=SPP6), size = 4.5,
                   alpha = 0.5, 
                   label.padding=.1, 
                   na.rm=TRUE,
                   seed = 1234) +
    geom_label_repel(data=species.long3, 
                    aes(x=axis1*4, y=axis2*4, colour=Seeded, label=SPP6), size =  4.5,
                   alpha = 1, 
                   label.padding=.1, 
                   fill = NA,
                   na.rm=TRUE,
                   seed = 1234) +
  scale_color_manual(name = "Vectors", breaks = c("Fall", "Summer", "Unseeded"),
                         labels = c("Sown Fall", "Sown Summer", "Unsown"),
                        values = c("darkblue", "#006400", "#444444"))+
    BioR.theme  +
    coord_fixed(ratio=1)+
  annotate("text", x = -1.25, y = 2.5, label = "Y2: 2023", size = 7, fontface =2)


dbRDA.2023.plot
```


### 2023 NMDS 
```{r, results = 'hide', echo = FALSE, message = FALSE, warning = FALSE, fig.show='hide'}

# Check the number of dimensions needed for the NMDS  (write the result of this test)

library(goeveg)
## Bray-Curtis dissimilarity
dimcheckMDS(inner.hel.2023, distance = "bray", k=6, trymax= 50, autotransform = FALSE)

###
## *** Best solution with three dimensions
```

```{r, echo = FALSE, results = 'hide', echo = FALSE, message = FALSE, warning = FALSE}
set.seed(5)
Bray_NMDS_2023 <- metaMDS(inner.hel.2023, distance = "bray", k=3, try=1000, trymax = 1000, autotransform =  FALSE)
```

```{r, results = 'hide', message = FALSE, echo = FALSE, warning = FALSE}
set.seed(5)
### Looks at which species were the most influential in driving the observed patterns

inner.spp.fit <- envfit(Bray_NMDS_2023, inner.hel.2023, permutations = 5000, k = 3)

#head(inner.spp.fit)
```

```{r, results = 'hide', message = FALSE, echo = FALSE, warning = FALSE, fig.show='hide'}

# Make a grouping variable so I can match site names to the NMDS output
site = c(rep(c("LE", "LL", "NAT", "SIM"), 6))

# Put the NMDS scores into it's own dataframe 
scrs <- as.data.frame(scores(Bray_NMDS_2023, display = "sites"))

# Match the NMDS scores to the right site labels
scrs <- cbind(scrs, site)

# Extracts the required scaling factor for the vector arrows
arrow_factor <- ordiArrowMul(inner.spp.fit)

# Take the envfit model and convert into a a dataframe (scaled)
spp.scrs <- as.data.frame(scores(inner.spp.fit, display = "vectors"))*arrow_factor

# Add the p values, R squared values to the envit model species score dataframe
spp.scrs <- cbind(spp.scrs, Species = rownames(spp.scrs), Pvalues = inner.spp.fit$vectors$pvals, R_squared = inner.spp.fit$vectors$r)


# Subset out species that had a p value <= 0.001 (since I think env fit truncates to 0.001)
spp.scrs.01 <- subset(spp.scrs, Pvalues < 0.01)

spp.scrs.01 <- tibble::rownames_to_column(spp.scrs.01, "SPP6")

species.long.1 <- left_join(spp.scrs.01, species_list_PE, by = "SPP6")


```

```{r, results = 'hide', message = FALSE, echo = FALSE, warning = FALSE, fig.show='hide'}

# Only including this plot because I need to call the plot in order to obtain the ordiellipse object

plot(Bray_NMDS_2023$points, xlim = c(-2, 2), ylim = c(-2, 2), col = alpha(0.5), xlab = "NMDS1", ylab = "NMDS2", cex.lab = 1.25, cex.axis = 1.25, bty="n")


# Store the ordiellipse data into a list
site.ellipses <- ordiellipse(Bray_NMDS_2023, groups = site, display = "sites", kind = "se", conf = 0.95)


# Convert the ordiellipse data into a dataframe that I can plot in ggplot
site.ellipses.long2 <- ordiellipse.long(site.ellipses, grouping.name="site")
```



```{r, results = 'hide', message = FALSE, echo = FALSE, warning = FALSE, fig.width = 8, fig.height = 8}

# Plot the species scores + the NMDS results

NMDS_plot_2023 <- ggplot(scrs) +
  geom_point(mapping = aes(x = NMDS1, y = NMDS2, 
                      fill = site, shape = site),
             size=2.5, alpha = 0.8) + 
  new_scale_color()+
  scale_shape_manual(name = "", 
                     values=c(21, 22,23, 25),
                     breaks=c("LE", "LL", "NAT", "SIM"),
                     labels = c("Summer first", "Fall first",
                                "Natural", "Simultaneous")) +
  scale_fill_manual(name = "",
                    values=c("#009E73", "#56B4E9",  "#F0E442","#0072B2"),
                    breaks=c("LE", "LL", "NAT", "SIM"), 
                    labels = c("Summer first", "Fall first",
                                "Natural", "Simultaneous")) +
  coord_fixed() +
  geom_segment(data = species.long.1, 
              aes(x = 0, xend = NMDS1 * arrow_factor, y = 0,
                  yend = NMDS2* arrow_factor),
                  arrow = arrow(length = unit(0.2, "cm")), 
                  color = "#888888", alpha = 0.7) +
  geom_text_repel(data = species.long.1,
                  aes(x = NMDS1 * arrow_factor, 
                      y = NMDS2 * arrow_factor,
                      label = Scientific_Name, color = Seeded),  
                      size = 3, max.overlaps = getOption("ggrepel.max.overlaps", default = 50) ) +
  scale_color_manual(name = "",
                     values=c("darkblue", "#003c00",  "#444444"),
                     breaks=c("Fall", "Summer", "Unseeded"), 
                     labels = c("Fall", "Summer", "Unseeded"))+
  new_scale_color()+
  geom_polygon(data = site.ellipses.long2, 
               aes(x = axis1, y=axis2, color = site, 
                   fill =   after_scale(alpha(color, 0.2))), 
               size = 0.2, show.legend = FALSE) +
   scale_color_manual(name = "",
                    values=c("#009E73", "#56B4E9",  "#F0E442","#0072B2"),
                    breaks=c("LE", "LL", "NAT", "SIM"), 
                    labels = c("Summer first", "Fall first",
                                "Natural", "Simultaneous"))+
  annotate("text", x = -.67, y = 1,
           label = "bold(Stress) == 0.12", parse = TRUE)+
  annotate("text", x = -.8, y = .9, 
           label = "bold(K) == 3", parse = TRUE) +
  theme_classic() +
  theme(text=element_text(size=18), 
        legend.key.size=unit(0.5, "cm"),
        legend.position = "right")+
  scale_y_continuous(breaks = seq(-0.5, 1, by = .5),
                     limits = c(-0.8, 1))+
  scale_x_continuous(breaks = seq(-0.8, .8, by = .4),
                     limits = c(-1, .8))




NMDS_plot_2023
```


```{r}
adonis2(inner.hel.2023 ~ Treatment, data = env.data.2023,  dist="bray")

### Pair-wise comparisons
library(pairwiseAdonis)
pairwise.adonis2(inner.hel.2023 ~ Treatment, data = env.data.2023, p.adjust = "bonferroni")

```


### Plot Panel

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 12, fig.height = 12}


legend_1 <- get_legend(dbRDA.2023.plot)

rm_legend <- function(p){p + theme(legend.position = "none")}

RDA_panel <- ggarrange(rm_legend(dbRDA.2022.plot), rm_legend(dbRDA.2023.plot),
align='h', labels=c('A', 'B'), ncol = 1, font.label = list(size = 20))

RDA_panel_legend <- ggarrange(RDA_panel, legend_1, ncol = 2, widths = c(1, 0.15)) +theme(plot.margin = margin(1,1,1,1, "cm"))

RDA_panel_legend 



```

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 10, fig.height = 10}

legend_1 <- get_legend(NMDS_plot_2022)

NMDS_plot_2022 <- NMDS_plot_2022 + theme(plot.margin = margin(0,0,0,8, "cm"))

NMDS_plot_2023 <- NMDS_plot_2023 + theme(plot.margin = margin(0,0,0,8, "cm"))

NMDS_Panel <- ggarrange(rm_legend(NMDS_plot_2022), rm_legend(NMDS_plot_2023), labels = c("A)", "B)"), hjust = -15, ncol = 1)


NMDS_Panel2 <- ggarrange(NMDS_Panel, legend_1 , heights = c(2, 0.5), widths = c(2, 0.5), ncol = 2)

NMDS_Panel2 
```

##  Question 3b: Does timing of species arrival influence species composition? - Jaccard {.tabset}




### Year: 2022




```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}
# 
# #Make a wide formatted dataset
# inner_wide_2022 <- inner_cover_max_reduced_lumped  %>%
#   filter(Year %in% 2022) %>% 
#   group_by(Block, Treatment, SPP6) %>% 
#   summarize(max_cover = sum(max_cover)) %>% 
#   spread(key="SPP6", value="max_cover") 
# 
# #Replace NA values with 0
# 
# inner_wide_2022[is.na(inner_wide_2022)] <- 0 
# 
# #Turn our dataset into a matrix 
# inner_wide_mat_2022 <- inner_wide_2022[,-c(1,2)]
# 
# 
# # labels
# inner_wide_labels_2022 <- inner_wide_2022[,c(1,2)]
# 
# ## Bare ground dataset
# inner_bare_cover_2022 <- inner_bare_cover %>% 
#   filter(Year == "2022") %>% 
#   filter(Treatment != "2022") %>% 
#    rename("Bare_cover" = "max_cover") %>% 
#   select(-SPP6)
# 
# ## Light dataset
# 
# light_2022 <- light_fall_2022 %>% 
#   filter(Treatment != "EMP") %>% 
#   group_by(Block, Treatment, Location) %>% 
#   summarize(Mean_Light = mean(Light))  %>% 
#   spread(key = Location , value = Mean_Light)
# 
# ## join
# 
# env.data.2022.bare <- full_join(inner_wide_labels_2022, inner_bare_cover_2022) 
# 
# env.data.2022 <- full_join(env.data.2022.bare, light_2022) 
# 
# env.data.2022 <- env.data.2022 %>% 
#  unite(UniqueBlock, c(Treatment,Block), sep = "_", remove = FALSE)
# 
# 
# 
# 
# row.names(inner_wide_mat_2022 ) <- env.data.2022$UniqueBlock
# inner_wide_mat_2022 <- data.matrix(inner_wide_mat_2022 )
# 
# 
# 
# # Standardize by pa 
# 
# inner.pa.2022 <- decostand(inner_wide_mat_2022, "pa")
# 

```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
### fit a distance-based RDA 
#### Allows you to do a constrained ordination using non-Euclidean distance measures such as Bray-curtis dissimilarity (which is fitting for our data on plant communities)

#### it works by: 1) making the distance matrix based on your desired measure, 2) doing a PCoA, 3) taking the PCoA eigenvectors and putting them into an RDA.


### Use the capscale function (not the dbRDA since it doesn't provide species scores)

## Light and bare ground were not important predictors


# 
# dbRDA.22.jac <- capscale(inner.pa.2022 ~ Treatment, data =env.data.2022 ,  dist="jaccard", add = TRUE)
# 
# ## dbRDA results
# dbRDA.22.jac
# 
# env.data.2022$Block <- as.factor(env.data.2022$Block)
# 
# ## PERMANOVA results
# 
# anova(dbRDA.22.jac, step = 1000, by = "terms", permu = 999)
# 
# 
# ### Pair-wise comparisons
# 
# BiodiversityR::multiconstrained(method = "capscale", inner.pa.2022  ~ Treatment, data = env.data.2022, by = "term", dist="jaccard", add = TRUE)

```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
### Get the basic ordination plot 

# plot1 <- ordiplot(dbRDA.22.jac, choices = c(1,2))
```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
### extract the site information

# sites.long1 <- sites.long(plot1, env.data = env.data.2022)
# 
# head(sites.long1)
# 
# ### extract the species information
# 
# species.long1 <- species.long(plot1)
# species.long1
# 
# ### extract the first two axis info
# 
# axis.long1 <- axis.long(dbRDA.22.jac, choices = c(1,2))
# axis.long1 
```




```{r, echo = FALSE,  message = FALSE, warning = FALSE}
# Do an envfit to find influential speicies (p < 0.05)

# 
# spec.envfit1 <- envfit(plot1, env=inner.pa.2022)
# spec.data.envfit1 <- data.frame(r=spec.envfit1$vectors$r, p=spec.envfit1$vectors$pvals)
# species.long1 <- species.long(plot1, spec.data=spec.data.envfit1)
# species.long1
# 
# 
# species.long.1 <- species.long1[species.long1$p < 0.01, ]
# species.long.1
# 
# # Join influential species dataframe to species list information so we can later color species labels by seeded status
# 
# species.long.1 <- species.long.1 %>% 
#   rename(SPP6 = "labels")
# 
# species.long.1 <- left_join(species.long.1, species_list_PE, by = "SPP6")
```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
# Get the vector information for environmental variables

#vectors.envfit.22 <- envfit(plot1, env=env.data.2022)
#vectors.long.1 <- vectorfit.long(vectors.envfit.22 )
#vectors.long.1

```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
# Get the ellipse information
# 
# ordiplot(dbRDA.22.jac, choices = c(1,2))
# Treatment.ellipses.22 <- ordiellipse(plot1, groups=env.data.2022$Treatment, display="sites", kind="sd")
# Treatment.ellipses.22.1 <- ordiellipse.long(Treatment.ellipses.22 , grouping.name="Treatment")
```

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 10, fig.height = 10}

# # Plot it!
# 
# 
# dbRDA.2022.plot.jac <- ggplot() + 
#     geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
#     geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +  
#     xlab(axis.long1[1, "label"]) +
#     ylab(axis.long1[2, "label"]) +  
#     scale_fill_manual(name = "Treatment", breaks = c("LE", "LL", "NAT", "NON", "SIM"),
#                          labels = c("Summer first", "Fall first", "Natural", "No seeding", "Simultaneous"),
#                          values = c("#009E73", "#56B4E9",  "#F0E442","#E69F00", "#0072B2"))+
#     scale_shape_manual(name = "Treatment", breaks = c("LE", "LL", "NAT", "NON", "SIM"),
#                          labels = c("Summer first", "Fall first", "Natural", "No seeding", "Simultaneous"),
#                          values = c(21, 22, 23, 24, 25))+
#   geom_polygon(data=Treatment.ellipses.22.1, 
#                    aes(x=axis1, y=axis2, fill=Treatment, alpha = 0.1), 
#               size=0.2, show.legend=FALSE) +
#   geom_point(data=sites.long1, 
#                aes(x=axis1, y=axis2, fill=Treatment, shape=Treatment), 
#                size=4.5) +
#   geom_segment(data=species.long.1, 
#                  aes(x=0, y=0, xend=axis1*4, yend=axis2*4), 
#                  colour="grey0", size=.8, alpha = 0.4) +
#   scale_color_manual(name = "Species", breaks = c("Fall", "Summer", "Unseeded", "Env."),
#                          labels = c("Seeded fall dispersing", "Seeded summer dispersing", "Unseeded", "Midstory light"),
#                          values = c("darkblue", "#003c00",  "#cc461b", "black"))+
#     geom_label_repel(data=species.long.1, aes(x=axis1*4, y=axis2*4, colour=Seeded, label=SPP6), size = 4.5,
#                    alpha = 0.5, 
#                    label.padding=.1, 
#                    na.rm=TRUE,
#                    seed = 1234) +
#     geom_label_repel(data=species.long.1, 
#                     aes(x=axis1*4, y=axis2*4, colour=Seeded, label=SPP6), size =  4.5,
#                    alpha = 1, 
#                    label.padding=.1, 
#                    fill = NA,
#                    na.rm=TRUE,
#                    seed = 1234) +
#     BioR.theme  +
#     coord_fixed(ratio=1)+
#   annotate("text", x = -0.5, y = 2, label = "Y1: 2022", size = 7, fontface =2)
# 
# dbRDA.2022.plot.jac


```



### Year: 2023

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 12, fig.height = 4}

# #Make a wide formatted dataset
# inner_wide_2023 <- inner_cover_max_reduced_lumped  %>%
#   filter(Year %in% 2023) %>% 
#   spread(key="SPP6", value="max_cover") 
# 
# #Replace NA values with 0
# 
# inner_wide_2023[is.na(inner_wide_2023)] <- 0 
# 
# #Turn our dataset into a matrix 
# inner_wide_mat_2023 <- inner_wide_2023[,-c(1,2,3)]
# 
# # make new dataset for labels & envdata
# 
# ## get the treatment labels
# inner_wide_labels_2023 <- inner_wide_2023[,c(1,2,3)]
# 
# ## Bare ground dataset
# inner_bare_cover_2023 <- inner_bare_cover %>% 
#   filter(Year == "2023") %>% 
#    rename("Bare_cover" = "max_cover") %>% 
#   select(-SPP6)
# 
# ## Light dataset
# 
# light_2023 <- light_fall_2023 %>% 
#   group_by(Block, Treatment, Location) %>% 
#   summarize(Mean_Light = mean(Light)) %>% 
#   spread(key = Location , value = Mean_Light)
# 
# ## join
# 
# env.data.2023.bare <- full_join(inner_wide_labels_2023, inner_bare_cover_2023) 
# 
# env.data.2023 <- full_join(env.data.2023.bare, light_2023)
# 
# # Standardize by max 
# 
# inner.pa.2023 <- decostand(inner_wide_mat_2023, "pa")

```


```{r, echo = FALSE,  message = FALSE, warning = FALSE}
### fit a distance-based RDA 
#### Allows you to do a constrained ordination using non-Euclidean distance measures such as Bray-curtis dissimilarity (which is fitting for our data on plant communities)

#### it works by: 1) making the distance matrix based on your desired measure, 2) doing a PCoA, 3) taking the PCoA eigenvectors and putting them into an RDA.

# 
# ### Use the capscale function (not the dbRDA since it doesn't provide species scores)
# dbRDA.jac <- capscale(inner.pa.2023  ~ Treatment, data = env.data.2023,  dist="jaccard", add = TRUE)
# 
# ## dbRDA results
# dbRDA.jac
# 
# ## PERMANOVA results
# anova(dbRDA.jac, step = 1000, by = "terms", permu = 999)
# 
# ### Pair-wise comparisons
# 
# BiodiversityR::multiconstrained(method = "capscale", inner.pa.2023  ~ Treatment, data = env.data.2023,  dist="jaccard", add = TRUE)
```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
### Get the basic ordination plot 

# plot2 <- ordiplot(dbRDA.jac, choices = c(1,2))
```

```{r, echo = FALSE,  message = FALSE, warning = FALSE}
### extract the site information
# 
# sites.long2 <- sites.long(plot2, env.data = env.data.2023)
# 
# head(sites.long2)
# 
# ### extract the species information
# 
# species.long2 <- species.long(plot2)
# species.long2
# 
# ### extract the first two axis info
# 
# axis.long2 <- axis.long(dbRDA.jac, choices = c(1,2))
# axis.long2 
```



```{r, echo = FALSE,  message = FALSE, warning = FALSE}
# Do an envfit to find influential speicies (p < 0.05)

# 
# spec.envfit <- envfit(plot2, env=inner.pa.2023)
# spec.data.envfit <- data.frame(r=spec.envfit$vectors$r, p=spec.envfit$vectors$pvals)
# species.long2 <- species.long(plot2, spec.data=spec.data.envfit)
# species.long2
# 
# 
# species.long3 <- species.long2[species.long2$p < 0.01, ]
# species.long3
# 
# # Join influential species dataframe to species list information so we can later color species labels by seeded status
# 
# species.long3 <- species.long3 %>% 
#   rename(SPP6 = "labels")
# 
# species.long3 <- left_join(species.long3, species_list_PE, by = "SPP6")
# 
# 

```



```{r, echo = FALSE,  message = FALSE, warning = FALSE}
# Get the ellipse information

# ordiplot(dbRDA.jac, choices = c(1,2))
# Treatment.ellipses <- ordiellipse(plot2, groups=env.data.2023$Treatment, display="sites", kind="sd")
# Treatment.ellipses.long2 <- ordiellipse.long(Treatment.ellipses, grouping.name="Treatment")
```

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 10, fig.height = 10}
# 
# # Plot it!
# 
# 
# dbRDA.2023.plot.jac <- ggplot() + 
#     geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
#     geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +  
#     xlab(axis.long2[1, "label"]) +
#     ylab(axis.long2[2, "label"]) +  
#    # scale_x_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +
#    # scale_y_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +  
#     scale_fill_manual(name = "Treatment", breaks = c("LE", "LL", "NAT", "NON", "SIM"),
#                          labels = c("Summer first", "Fall first", "Natural", "No seeding", "Simultaneous"),
#                          values = c("#009E73", "#56B4E9",  "#F0E442","#E69F00", "#0072B2"))+
#     scale_shape_manual(name = "Treatment", breaks = c("LE", "LL", "NAT", "NON", "SIM"),
#                          labels = c("Summer first", "Fall first", "Natural", "No seeding", "Simultaneous"),
#                          values = c(21, 22, 23, 24, 25))+
#     geom_polygon(data=Treatment.ellipses.long2, 
#                    aes(x=axis1, y=axis2, fill=Treatment, alpha = 0.1), 
#               size=0.2, show.legend=FALSE) +
#   geom_point(data=sites.long2, 
#                aes(x=axis1, y=axis2, fill=Treatment, shape=Treatment), 
#                size=4.5) +
#   geom_segment(data=species.long3, 
#                  aes(x=0, y=0, xend=axis1*4, yend=axis2*4), 
#                  colour="grey0", size=0.8, alpha = 0.4) +
#     geom_label_repel(data=species.long3, aes(x=axis1*4, y=axis2*4, colour=Seeded, label=SPP6), size = 4.5,
#                    alpha = 0.5, 
#                    label.padding=.1, 
#                    na.rm=TRUE,
#                    seed = 1234) +
#     geom_label_repel(data=species.long3, 
#                     aes(x=axis1*4, y=axis2*4, colour=Seeded, label=SPP6), size =  4.5,
#                    alpha = 1, 
#                    label.padding=.1, 
#                    fill = NA,
#                    na.rm=TRUE,
#                    seed = 1234) +
#   scale_color_manual(name = "Vectors", breaks = c("Fall", "Summer", "Unseeded", "Env."),
#                          labels = c("Seeded fall dispersing species", "Seeded summer dispersing species", "Unseeded species", "Midstory light"),
#                         values = c("darkblue", "#003c00",  "#cc461b", "black"))+
#     BioR.theme  +
#     coord_fixed(ratio=1)+
#   annotate("text", x = -1.5, y = 2.5, label = "Y2: 2023", size = 7, fontface =2)
# 
# 
# dbRDA.2023.plot.jac
```


### Plot Panel

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.width = 12, fig.height = 12}

# RDA_panel.jac <- ggarrange(dbRDA.2022.plot.jac, dbRDA.2023.plot.jac,
# align='h', labels=c('A', 'B'), ncol = 1,
# common.legend = T, legend = "right", font.label = list(size = 20))
# 
# RDA_panel.jac
```
